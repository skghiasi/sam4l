
BaseProject.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000011b8  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000464  20000000  000011b8  00020000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          0000007c  20000464  0000161c  00020464  2**2
                  ALLOC
  3 .stack        00001000  200004e0  00001698  00020464  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00020464  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  0002048e  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001009f  00000000  00000000  000204e7  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001e3e  00000000  00000000  00030586  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00004e32  00000000  00000000  000323c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000007d0  00000000  00000000  000371f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000750  00000000  00000000  000379c6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0002d199  00000000  00000000  00038116  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000a9db  00000000  00000000  000652af  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    000e38d1  00000000  00000000  0006fc8a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000014c4  00000000  00000000  0015355c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
volatile bool g_interrupt_enabled = true;
#endif

void cpu_irq_enter_critical(void)
{
	if (cpu_irq_critical_section_counter == 0) {
       0:	e0 14 00 20 09 0e 00 00 07 0e 00 00 07 0e 00 00     ... ............
		if (cpu_irq_is_enabled()) {
			cpu_irq_disable();
			cpu_irq_prev_interrupt_state = true;
		} else {
			/* Make sure the to save the prev state as false */
			cpu_irq_prev_interrupt_state = false;
      10:	07 0e 00 00 07 0e 00 00 07 0e 00 00 00 00 00 00     ................
	...
			cpu_irq_prev_interrupt_state = true;
      2c:	07 0e 00 00 07 0e 00 00 00 00 00 00 07 0e 00 00     ................
      3c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      4c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      5c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      6c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      7c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      8c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      9c:	07 0e 00 00 07 0e 00 00 21 0d 00 00 31 0d 00 00     ........!...1...
      ac:	45 0d 00 00 59 0d 00 00 6d 0d 00 00 7d 0d 00 00     E...Y...m...}...
      bc:	91 0d 00 00 a5 0d 00 00 b9 0d 00 00 c9 0d 00 00     ................
      cc:	dd 0d 00 00 f1 0d 00 00 07 0e 00 00 07 0e 00 00     ................
      dc:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      ec:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
      fc:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     10c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     11c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     12c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     13c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 8d 0e 00 00     ................
     14c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     15c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     16c:	07 0e 00 00 07 0e 00 00 07 0e 00 00 07 0e 00 00     ................
     17c:	07 0e 00 00                                         ....

00000180 <__do_global_dtors_aux>:
     180:	b510      	push	{r4, lr}
     182:	4c05      	ldr	r4, [pc, #20]	; (198 <__do_global_dtors_aux+0x18>)
     184:	7823      	ldrb	r3, [r4, #0]
     186:	b933      	cbnz	r3, 196 <__do_global_dtors_aux+0x16>
     188:	4b04      	ldr	r3, [pc, #16]	; (19c <__do_global_dtors_aux+0x1c>)
     18a:	b113      	cbz	r3, 192 <__do_global_dtors_aux+0x12>
     18c:	4804      	ldr	r0, [pc, #16]	; (1a0 <__do_global_dtors_aux+0x20>)
     18e:	f3af 8000 	nop.w
     192:	2301      	movs	r3, #1
     194:	7023      	strb	r3, [r4, #0]
     196:	bd10      	pop	{r4, pc}
     198:	20000464 	.word	0x20000464
     19c:	00000000 	.word	0x00000000
     1a0:	000011b8 	.word	0x000011b8

000001a4 <frame_dummy>:
     1a4:	4b0c      	ldr	r3, [pc, #48]	; (1d8 <frame_dummy+0x34>)
     1a6:	b143      	cbz	r3, 1ba <frame_dummy+0x16>
     1a8:	480c      	ldr	r0, [pc, #48]	; (1dc <frame_dummy+0x38>)
     1aa:	490d      	ldr	r1, [pc, #52]	; (1e0 <frame_dummy+0x3c>)
     1ac:	b510      	push	{r4, lr}
     1ae:	f3af 8000 	nop.w
     1b2:	480c      	ldr	r0, [pc, #48]	; (1e4 <frame_dummy+0x40>)
     1b4:	6803      	ldr	r3, [r0, #0]
     1b6:	b923      	cbnz	r3, 1c2 <frame_dummy+0x1e>
     1b8:	bd10      	pop	{r4, pc}
     1ba:	480a      	ldr	r0, [pc, #40]	; (1e4 <frame_dummy+0x40>)
     1bc:	6803      	ldr	r3, [r0, #0]
     1be:	b933      	cbnz	r3, 1ce <frame_dummy+0x2a>
     1c0:	4770      	bx	lr
     1c2:	4b09      	ldr	r3, [pc, #36]	; (1e8 <frame_dummy+0x44>)
     1c4:	2b00      	cmp	r3, #0
     1c6:	d0f7      	beq.n	1b8 <frame_dummy+0x14>
     1c8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     1cc:	4718      	bx	r3
     1ce:	4b06      	ldr	r3, [pc, #24]	; (1e8 <frame_dummy+0x44>)
     1d0:	2b00      	cmp	r3, #0
     1d2:	d0f5      	beq.n	1c0 <frame_dummy+0x1c>
     1d4:	4718      	bx	r3
     1d6:	bf00      	nop
     1d8:	00000000 	.word	0x00000000
     1dc:	000011b8 	.word	0x000011b8
     1e0:	20000468 	.word	0x20000468
     1e4:	000011b8 	.word	0x000011b8
     1e8:	00000000 	.word	0x00000000

000001ec <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock
 * frequency.
 */
uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
     1ec:	b410      	push	{r4}
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
     1ee:	010b      	lsls	r3, r1, #4
     1f0:	4293      	cmp	r3, r2
     1f2:	d914      	bls.n	21e <usart_set_async_baudrate+0x32>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
	}

	/* Calculate clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
     1f4:	00c9      	lsls	r1, r1, #3
     1f6:	084b      	lsrs	r3, r1, #1
     1f8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
     1fc:	fbb2 f2f1 	udiv	r2, r2, r1
	cd = cd_fp >> 3;
     200:	08d3      	lsrs	r3, r2, #3
	fp = cd_fp & 0x07;
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
     202:	1e5c      	subs	r4, r3, #1
     204:	f64f 71fe 	movw	r1, #65534	; 0xfffe
     208:	428c      	cmp	r4, r1
     20a:	d901      	bls.n	210 <usart_set_async_baudrate+0x24>
		return 1;
     20c:	2001      	movs	r0, #1
     20e:	e017      	b.n	240 <usart_set_async_baudrate+0x54>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
		p_usart->US_MR |= US_MR_OVER;
     210:	6841      	ldr	r1, [r0, #4]
     212:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
     216:	6041      	str	r1, [r0, #4]
     218:	e00c      	b.n	234 <usart_set_async_baudrate+0x48>
		return 1;
     21a:	2001      	movs	r0, #1
     21c:	e010      	b.n	240 <usart_set_async_baudrate+0x54>
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
     21e:	0859      	lsrs	r1, r3, #1
     220:	eb01 02c2 	add.w	r2, r1, r2, lsl #3
     224:	fbb2 f2f3 	udiv	r2, r2, r3
	cd = cd_fp >> 3;
     228:	08d3      	lsrs	r3, r2, #3
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
     22a:	1e5c      	subs	r4, r3, #1
     22c:	f64f 71fe 	movw	r1, #65534	; 0xfffe
     230:	428c      	cmp	r4, r1
     232:	d8f2      	bhi.n	21a <usart_set_async_baudrate+0x2e>
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
     234:	0412      	lsls	r2, r2, #16
     236:	f402 22e0 	and.w	r2, r2, #458752	; 0x70000
     23a:	431a      	orrs	r2, r3
     23c:	6202      	str	r2, [r0, #32]

	return 0;
     23e:	2000      	movs	r0, #0
}
     240:	bc10      	pop	{r4}
     242:	4770      	bx	lr

00000244 <usart_reset>:
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
	p_usart->US_WPMR = US_WPMR_WPKEY_PASSWD;
     244:	4b0a      	ldr	r3, [pc, #40]	; (270 <usart_reset+0x2c>)
     246:	f8c0 30e4 	str.w	r3, [r0, #228]	; 0xe4
	p_usart->US_MR = 0;
     24a:	2300      	movs	r3, #0
     24c:	6043      	str	r3, [r0, #4]
	p_usart->US_RTOR = 0;
     24e:	6243      	str	r3, [r0, #36]	; 0x24
	p_usart->US_TTGR = 0;
     250:	6283      	str	r3, [r0, #40]	; 0x28
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
     252:	2388      	movs	r3, #136	; 0x88
     254:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
     256:	2324      	movs	r3, #36	; 0x24
     258:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RSTSTA;
     25a:	f44f 7380 	mov.w	r3, #256	; 0x100
     25e:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_RTSDIS;
     260:	f44f 2300 	mov.w	r3, #524288	; 0x80000
     264:	6003      	str	r3, [r0, #0]
	p_usart->US_CR = US_CR_DTRDIS;
     266:	f44f 3300 	mov.w	r3, #131072	; 0x20000
     26a:	6003      	str	r3, [r0, #0]
     26c:	4770      	bx	lr
     26e:	bf00      	nop
     270:	55534100 	.word	0x55534100

00000274 <usart_init_rs232>:
{
     274:	b570      	push	{r4, r5, r6, lr}
     276:	4605      	mov	r5, r0
     278:	460c      	mov	r4, r1
     27a:	4616      	mov	r6, r2
	usart_reset(p_usart);
     27c:	4b0f      	ldr	r3, [pc, #60]	; (2bc <usart_init_rs232+0x48>)
     27e:	4798      	blx	r3
	ul_reg_val = 0;
     280:	2200      	movs	r2, #0
     282:	4b0f      	ldr	r3, [pc, #60]	; (2c0 <usart_init_rs232+0x4c>)
     284:	601a      	str	r2, [r3, #0]
	if (!p_usart_opt || usart_set_async_baudrate(p_usart,
     286:	b1a4      	cbz	r4, 2b2 <usart_init_rs232+0x3e>
     288:	4632      	mov	r2, r6
     28a:	6821      	ldr	r1, [r4, #0]
     28c:	4628      	mov	r0, r5
     28e:	4b0d      	ldr	r3, [pc, #52]	; (2c4 <usart_init_rs232+0x50>)
     290:	4798      	blx	r3
     292:	4602      	mov	r2, r0
     294:	b978      	cbnz	r0, 2b6 <usart_init_rs232+0x42>
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
     296:	6863      	ldr	r3, [r4, #4]
     298:	68a1      	ldr	r1, [r4, #8]
     29a:	430b      	orrs	r3, r1
     29c:	6921      	ldr	r1, [r4, #16]
     29e:	430b      	orrs	r3, r1
			p_usart_opt->channel_mode | p_usart_opt->stop_bits;
     2a0:	68e1      	ldr	r1, [r4, #12]
     2a2:	430b      	orrs	r3, r1
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
     2a4:	4906      	ldr	r1, [pc, #24]	; (2c0 <usart_init_rs232+0x4c>)
     2a6:	600b      	str	r3, [r1, #0]
	p_usart->US_MR |= ul_reg_val;
     2a8:	6869      	ldr	r1, [r5, #4]
     2aa:	430b      	orrs	r3, r1
     2ac:	606b      	str	r3, [r5, #4]
}
     2ae:	4610      	mov	r0, r2
     2b0:	bd70      	pop	{r4, r5, r6, pc}
		return 1;
     2b2:	2201      	movs	r2, #1
     2b4:	e7fb      	b.n	2ae <usart_init_rs232+0x3a>
     2b6:	2201      	movs	r2, #1
     2b8:	e7f9      	b.n	2ae <usart_init_rs232+0x3a>
     2ba:	bf00      	nop
     2bc:	00000245 	.word	0x00000245
     2c0:	20000480 	.word	0x20000480
     2c4:	000001ed 	.word	0x000001ed

000002c8 <usart_enable_tx>:
	p_usart->US_CR = US_CR_TXEN;
     2c8:	2340      	movs	r3, #64	; 0x40
     2ca:	6003      	str	r3, [r0, #0]
     2cc:	4770      	bx	lr

000002ce <usart_enable_rx>:
	p_usart->US_CR = US_CR_RXEN;
     2ce:	2310      	movs	r3, #16
     2d0:	6003      	str	r3, [r0, #0]
     2d2:	4770      	bx	lr

000002d4 <usart_enable_interrupt>:
	p_usart->US_IER = ul_sources;
     2d4:	6081      	str	r1, [r0, #8]
     2d6:	4770      	bx	lr

000002d8 <usart_get_status>:
	return p_usart->US_CSR;
     2d8:	6940      	ldr	r0, [r0, #20]
}
     2da:	4770      	bx	lr

000002dc <usart_putchar>:
	while (!(p_usart->US_CSR & US_CSR_TXRDY)) {
     2dc:	6943      	ldr	r3, [r0, #20]
     2de:	f013 0f02 	tst.w	r3, #2
     2e2:	d0fb      	beq.n	2dc <usart_putchar>
	p_usart->US_THR = US_THR_TXCHR(c);
     2e4:	f3c1 0108 	ubfx	r1, r1, #0, #9
     2e8:	61c1      	str	r1, [r0, #28]
}
     2ea:	2000      	movs	r0, #0
     2ec:	4770      	bx	lr
	...

000002f0 <usart_write_line>:
{
     2f0:	b570      	push	{r4, r5, r6, lr}
     2f2:	460c      	mov	r4, r1
	while (*string != '\0') {
     2f4:	7809      	ldrb	r1, [r1, #0]
     2f6:	b139      	cbz	r1, 308 <usart_write_line+0x18>
     2f8:	4605      	mov	r5, r0
		usart_putchar(p_usart, *string++);
     2fa:	4e04      	ldr	r6, [pc, #16]	; (30c <usart_write_line+0x1c>)
     2fc:	4628      	mov	r0, r5
     2fe:	47b0      	blx	r6
	while (*string != '\0') {
     300:	f814 1f01 	ldrb.w	r1, [r4, #1]!
     304:	2900      	cmp	r1, #0
     306:	d1f9      	bne.n	2fc <usart_write_line+0xc>
     308:	bd70      	pop	{r4, r5, r6, pc}
     30a:	bf00      	nop
     30c:	000002dd 	.word	0x000002dd

00000310 <usart_read>:
	if (!(p_usart->US_CSR & US_CSR_RXRDY)) {
     310:	6943      	ldr	r3, [r0, #20]
     312:	f013 0f01 	tst.w	r3, #1
     316:	d005      	beq.n	324 <usart_read+0x14>
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
     318:	6983      	ldr	r3, [r0, #24]
     31a:	f3c3 0308 	ubfx	r3, r3, #0, #9
     31e:	600b      	str	r3, [r1, #0]
	return 0;
     320:	2000      	movs	r0, #0
     322:	4770      	bx	lr
		return 1;
     324:	2001      	movs	r0, #1
}
     326:	4770      	bx	lr

00000328 <osc_priv_enable_osc0>:
 */
#include <osc.h>

#ifdef BOARD_OSC0_HZ
void osc_priv_enable_osc0(void)
{
     328:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     32a:	f3ef 8310 	mrs	r3, PRIMASK
static volatile uint32_t cpu_irq_critical_section_counter;
static volatile bool     cpu_irq_prev_interrupt_state;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = cpu_irq_is_enabled();
     32e:	fab3 f383 	clz	r3, r3
     332:	095b      	lsrs	r3, r3, #5
     334:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     336:	b672      	cpsid	i
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
     338:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     33c:	2200      	movs	r2, #0
     33e:	4b08      	ldr	r3, [pc, #32]	; (360 <osc_priv_enable_osc0+0x38>)
     340:	701a      	strb	r2, [r3, #0]
	return flags;
     342:	9a01      	ldr	r2, [sp, #4]
	irqflags_t flags;

	flags = cpu_irq_save();
	SCIF->SCIF_UNLOCK = SCIF_UNLOCK_KEY(0xAAu)
     344:	4b07      	ldr	r3, [pc, #28]	; (364 <osc_priv_enable_osc0+0x3c>)
     346:	4908      	ldr	r1, [pc, #32]	; (368 <osc_priv_enable_osc0+0x40>)
     348:	6199      	str	r1, [r3, #24]
		| SCIF_UNLOCK_ADDR((uint32_t)&SCIF->SCIF_OSCCTRL0 - (uint32_t)SCIF);
	SCIF->SCIF_OSCCTRL0 =
     34a:	4908      	ldr	r1, [pc, #32]	; (36c <osc_priv_enable_osc0+0x44>)
     34c:	6219      	str	r1, [r3, #32]
	return (flags);
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	if (cpu_irq_is_enabled_flags(flags))
     34e:	b12a      	cbz	r2, 35c <osc_priv_enable_osc0+0x34>
		cpu_irq_enable();
     350:	2201      	movs	r2, #1
     352:	4b03      	ldr	r3, [pc, #12]	; (360 <osc_priv_enable_osc0+0x38>)
     354:	701a      	strb	r2, [r3, #0]
     356:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     35a:	b662      	cpsie	i
			| OSC0_GAIN_VALUE
#endif
			| OSC0_MODE_VALUE
			| SCIF_OSCCTRL0_OSCEN;
	cpu_irq_restore(flags);
}
     35c:	b002      	add	sp, #8
     35e:	4770      	bx	lr
     360:	20000030 	.word	0x20000030
     364:	400e0800 	.word	0x400e0800
     368:	aa000020 	.word	0xaa000020
     36c:	00010307 	.word	0x00010307

00000370 <sysclk_priv_enable_module>:
 * \brief Disable a module clock derived from the PBC clock
 * \param module_index Index of the module clock in the PBAMASK register
 */
static inline void sysclk_disable_pbc_module(uint32_t module_index)
{
	sysclk_priv_disable_module(PM_CLK_GRP_PBC, module_index);
     370:	b470      	push	{r4, r5, r6}
     372:	b083      	sub	sp, #12
     374:	f3ef 8310 	mrs	r3, PRIMASK
 * \brief Disable a module clock derived from the PBD clock
 * \param module_index Index of the module clock in the PBAMASK register
 */
static inline void sysclk_disable_pbd_module(uint32_t module_index)
{
	sysclk_priv_disable_module(PM_CLK_GRP_PBD, module_index);
     378:	fab3 f383 	clz	r3, r3
     37c:	095b      	lsrs	r3, r3, #5
     37e:	9301      	str	r3, [sp, #4]
     380:	b672      	cpsid	i
     382:	f3bf 8f5f 	dmb	sy
     386:	2200      	movs	r2, #0
     388:	4b0e      	ldr	r3, [pc, #56]	; (3c4 <sysclk_priv_enable_module+0x54>)
     38a:	701a      	strb	r2, [r3, #0]
     38c:	9d01      	ldr	r5, [sp, #4]
     38e:	0083      	lsls	r3, r0, #2
     390:	4c0d      	ldr	r4, [pc, #52]	; (3c8 <sysclk_priv_enable_module+0x58>)
     392:	f854 6020 	ldr.w	r6, [r4, r0, lsl #2]
     396:	2201      	movs	r2, #1
     398:	fa02 f101 	lsl.w	r1, r2, r1
     39c:	4331      	orrs	r1, r6
     39e:	3320      	adds	r3, #32
     3a0:	f403 737f 	and.w	r3, r3, #1020	; 0x3fc
     3a4:	f043 432a 	orr.w	r3, r3, #2852126720	; 0xaa000000
     3a8:	4a08      	ldr	r2, [pc, #32]	; (3cc <sysclk_priv_enable_module+0x5c>)
     3aa:	6593      	str	r3, [r2, #88]	; 0x58
	/* Enable the clock */
	mask = *(&PM->PM_CPUMASK + bus_id);
	mask |= 1U << module_index;
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu) |
		BPM_UNLOCK_ADDR(((uint32_t)&PM->PM_CPUMASK - (uint32_t)PM) + (4 * bus_id));
	*(&PM->PM_CPUMASK + bus_id) = mask;
     3ac:	f844 1020 	str.w	r1, [r4, r0, lsl #2]
	if (cpu_irq_is_enabled_flags(flags))
     3b0:	b12d      	cbz	r5, 3be <sysclk_priv_enable_module+0x4e>
		cpu_irq_enable();
     3b2:	2201      	movs	r2, #1
     3b4:	4b03      	ldr	r3, [pc, #12]	; (3c4 <sysclk_priv_enable_module+0x54>)
     3b6:	701a      	strb	r2, [r3, #0]
     3b8:	f3bf 8f5f 	dmb	sy
     3bc:	b662      	cpsie	i

	cpu_irq_restore(flags);
}
     3be:	b003      	add	sp, #12
     3c0:	bc70      	pop	{r4, r5, r6}
     3c2:	4770      	bx	lr
     3c4:	20000030 	.word	0x20000030
     3c8:	400e0020 	.word	0x400e0020
     3cc:	400e0000 	.word	0x400e0000

000003d0 <sysclk_enable_pba_module>:
/**
 * \brief Enable a module clock derived from the PBA clock
 * \param module_index Index of the module clock in the PBAMASK register
 */
void sysclk_enable_pba_module(uint32_t module_index)
{
     3d0:	b530      	push	{r4, r5, lr}
     3d2:	b083      	sub	sp, #12
     3d4:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     3d6:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
     3da:	fab3 f383 	clz	r3, r3
     3de:	095b      	lsrs	r3, r3, #5
     3e0:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     3e2:	b672      	cpsid	i
     3e4:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     3e8:	2200      	movs	r2, #0
     3ea:	4b0c      	ldr	r3, [pc, #48]	; (41c <sysclk_enable_pba_module+0x4c>)
     3ec:	701a      	strb	r2, [r3, #0]
	return flags;
     3ee:	9d01      	ldr	r5, [sp, #4]
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (PM->PM_PBAMASK == 0) {
     3f0:	4b0b      	ldr	r3, [pc, #44]	; (420 <sysclk_enable_pba_module+0x50>)
     3f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
     3f4:	b163      	cbz	r3, 410 <sysclk_enable_pba_module+0x40>
	if (cpu_irq_is_enabled_flags(flags))
     3f6:	b12d      	cbz	r5, 404 <sysclk_enable_pba_module+0x34>
		cpu_irq_enable();
     3f8:	2201      	movs	r2, #1
     3fa:	4b08      	ldr	r3, [pc, #32]	; (41c <sysclk_enable_pba_module+0x4c>)
     3fc:	701a      	strb	r2, [r3, #0]
     3fe:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     402:	b662      	cpsie	i
	}

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(PM_CLK_GRP_PBA, module_index);
     404:	4621      	mov	r1, r4
     406:	2002      	movs	r0, #2
     408:	4b06      	ldr	r3, [pc, #24]	; (424 <sysclk_enable_pba_module+0x54>)
     40a:	4798      	blx	r3
}
     40c:	b003      	add	sp, #12
     40e:	bd30      	pop	{r4, r5, pc}
	sysclk_priv_enable_module(PM_CLK_GRP_HSB, module_index);
     410:	2105      	movs	r1, #5
     412:	2001      	movs	r0, #1
     414:	4b03      	ldr	r3, [pc, #12]	; (424 <sysclk_enable_pba_module+0x54>)
     416:	4798      	blx	r3
     418:	e7ed      	b.n	3f6 <sysclk_enable_pba_module+0x26>
     41a:	bf00      	nop
     41c:	20000030 	.word	0x20000030
     420:	400e0000 	.word	0x400e0000
     424:	00000371 	.word	0x00000371

00000428 <sysclk_enable_pbb_module>:
/**
 * \brief Enable a module clock derived from the PBB clock
 * \param module_index Index of the module clock in the PBBMASK register
 */
void sysclk_enable_pbb_module(uint32_t module_index)
{
     428:	b530      	push	{r4, r5, lr}
     42a:	b083      	sub	sp, #12
     42c:	4604      	mov	r4, r0
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     42e:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
     432:	fab3 f383 	clz	r3, r3
     436:	095b      	lsrs	r3, r3, #5
     438:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     43a:	b672      	cpsid	i
     43c:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     440:	2200      	movs	r2, #0
     442:	4b0c      	ldr	r3, [pc, #48]	; (474 <sysclk_enable_pbb_module+0x4c>)
     444:	701a      	strb	r2, [r3, #0]
	return flags;
     446:	9d01      	ldr	r5, [sp, #4]
	irqflags_t flags;

	/* Enable the bridge if necessary */
	flags = cpu_irq_save();

	if (PM->PM_PBBMASK == 0) {
     448:	4b0b      	ldr	r3, [pc, #44]	; (478 <sysclk_enable_pbb_module+0x50>)
     44a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
     44c:	b163      	cbz	r3, 468 <sysclk_enable_pbb_module+0x40>
	if (cpu_irq_is_enabled_flags(flags))
     44e:	b12d      	cbz	r5, 45c <sysclk_enable_pbb_module+0x34>
		cpu_irq_enable();
     450:	2201      	movs	r2, #1
     452:	4b08      	ldr	r3, [pc, #32]	; (474 <sysclk_enable_pbb_module+0x4c>)
     454:	701a      	strb	r2, [r3, #0]
     456:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     45a:	b662      	cpsie	i
	}

	cpu_irq_restore(flags);

	/* Enable the module */
	sysclk_priv_enable_module(PM_CLK_GRP_PBB, module_index);
     45c:	4621      	mov	r1, r4
     45e:	2003      	movs	r0, #3
     460:	4b06      	ldr	r3, [pc, #24]	; (47c <sysclk_enable_pbb_module+0x54>)
     462:	4798      	blx	r3
}
     464:	b003      	add	sp, #12
     466:	bd30      	pop	{r4, r5, pc}
     468:	2106      	movs	r1, #6
     46a:	2001      	movs	r0, #1
     46c:	4b03      	ldr	r3, [pc, #12]	; (47c <sysclk_enable_pbb_module+0x54>)
     46e:	4798      	blx	r3
     470:	e7ed      	b.n	44e <sysclk_enable_pbb_module+0x26>
     472:	bf00      	nop
     474:	20000030 	.word	0x20000030
     478:	400e0000 	.word	0x400e0000
     47c:	00000371 	.word	0x00000371

00000480 <sysclk_get_peripheral_bus_hz>:
 * \return Frequency of the bus attached to the specified peripheral, in Hz.
 */
uint32_t sysclk_get_peripheral_bus_hz(const volatile void *module)
{
	/* Fallthroughs intended for modules sharing the same peripheral bus. */
	switch ((uintptr_t)module) {
     480:	4b5a      	ldr	r3, [pc, #360]	; (5ec <sysclk_get_peripheral_bus_hz+0x16c>)
     482:	4298      	cmp	r0, r3
     484:	d027      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     486:	d858      	bhi.n	53a <sysclk_get_peripheral_bus_hz+0xba>
     488:	f5a3 23a0 	sub.w	r3, r3, #327680	; 0x50000
     48c:	4298      	cmp	r0, r3
     48e:	d022      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     490:	d910      	bls.n	4b4 <sysclk_get_peripheral_bus_hz+0x34>
     492:	4b57      	ldr	r3, [pc, #348]	; (5f0 <sysclk_get_peripheral_bus_hz+0x170>)
     494:	4298      	cmp	r0, r3
     496:	d01e      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     498:	d935      	bls.n	506 <sysclk_get_peripheral_bus_hz+0x86>
     49a:	4b56      	ldr	r3, [pc, #344]	; (5f4 <sysclk_get_peripheral_bus_hz+0x174>)
     49c:	4298      	cmp	r0, r3
     49e:	d01a      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4a0:	d843      	bhi.n	52a <sysclk_get_peripheral_bus_hz+0xaa>
     4a2:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
     4a6:	4298      	cmp	r0, r3
     4a8:	d015      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4aa:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     4ae:	4298      	cmp	r0, r3
     4b0:	d116      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     4b2:	e010      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4b4:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     4b8:	4298      	cmp	r0, r3
     4ba:	d00c      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4bc:	d812      	bhi.n	4e4 <sysclk_get_peripheral_bus_hz+0x64>
     4be:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     4c2:	4298      	cmp	r0, r3
     4c4:	d007      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4c6:	d908      	bls.n	4da <sysclk_get_peripheral_bus_hz+0x5a>
     4c8:	4b4b      	ldr	r3, [pc, #300]	; (5f8 <sysclk_get_peripheral_bus_hz+0x178>)
     4ca:	4298      	cmp	r0, r3
     4cc:	d003      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4ce:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     4d2:	4298      	cmp	r0, r3
     4d4:	d104      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
	case TWIM2_ADDR:
	case TWIM3_ADDR:
	#if !SAM4LS
	case LCDCA_ADDR:
	#endif
		return sysclk_get_pba_hz();
     4d6:	4849      	ldr	r0, [pc, #292]	; (5fc <sysclk_get_peripheral_bus_hz+0x17c>)

	default:
		Assert(false);
		return 0;
	}
}
     4d8:	4770      	bx	lr
	switch ((uintptr_t)module) {
     4da:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
     4de:	d0fa      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
		return 0;
     4e0:	2000      	movs	r0, #0
     4e2:	4770      	bx	lr
	switch ((uintptr_t)module) {
     4e4:	4b46      	ldr	r3, [pc, #280]	; (600 <sysclk_get_peripheral_bus_hz+0x180>)
     4e6:	4298      	cmp	r0, r3
     4e8:	d0f5      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4ea:	d907      	bls.n	4fc <sysclk_get_peripheral_bus_hz+0x7c>
     4ec:	4b45      	ldr	r3, [pc, #276]	; (604 <sysclk_get_peripheral_bus_hz+0x184>)
     4ee:	4298      	cmp	r0, r3
     4f0:	d0f1      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4f2:	f503 43f8 	add.w	r3, r3, #31744	; 0x7c00
     4f6:	4298      	cmp	r0, r3
     4f8:	d1f2      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     4fa:	e7ec      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     4fc:	f5a3 5370 	sub.w	r3, r3, #15360	; 0x3c00
     500:	4298      	cmp	r0, r3
     502:	d1ed      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     504:	e7e7      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     506:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     50a:	4298      	cmp	r0, r3
     50c:	d0e3      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     50e:	d907      	bls.n	520 <sysclk_get_peripheral_bus_hz+0xa0>
     510:	4b3d      	ldr	r3, [pc, #244]	; (608 <sysclk_get_peripheral_bus_hz+0x188>)
     512:	4298      	cmp	r0, r3
     514:	d0df      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     516:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     51a:	4298      	cmp	r0, r3
     51c:	d1e0      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     51e:	e7da      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     520:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
     524:	4298      	cmp	r0, r3
     526:	d1db      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     528:	e7d5      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     52a:	4b38      	ldr	r3, [pc, #224]	; (60c <sysclk_get_peripheral_bus_hz+0x18c>)
     52c:	4298      	cmp	r0, r3
     52e:	d0d2      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     530:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     534:	4298      	cmp	r0, r3
     536:	d1d3      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     538:	e7cd      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     53a:	4b35      	ldr	r3, [pc, #212]	; (610 <sysclk_get_peripheral_bus_hz+0x190>)
     53c:	4298      	cmp	r0, r3
     53e:	d0ca      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     540:	d910      	bls.n	564 <sysclk_get_peripheral_bus_hz+0xe4>
     542:	4b34      	ldr	r3, [pc, #208]	; (614 <sysclk_get_peripheral_bus_hz+0x194>)
     544:	4298      	cmp	r0, r3
     546:	d0c6      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     548:	d934      	bls.n	5b4 <sysclk_get_peripheral_bus_hz+0x134>
     54a:	4b33      	ldr	r3, [pc, #204]	; (618 <sysclk_get_peripheral_bus_hz+0x198>)
     54c:	4298      	cmp	r0, r3
     54e:	d0c2      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     550:	d842      	bhi.n	5d8 <sysclk_get_peripheral_bus_hz+0x158>
     552:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
     556:	4298      	cmp	r0, r3
     558:	d0bd      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     55a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     55e:	4298      	cmp	r0, r3
     560:	d1be      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     562:	e7b8      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     564:	f5a3 337c 	sub.w	r3, r3, #258048	; 0x3f000
     568:	4298      	cmp	r0, r3
     56a:	d0b4      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     56c:	d811      	bhi.n	592 <sysclk_get_peripheral_bus_hz+0x112>
     56e:	f5a3 3304 	sub.w	r3, r3, #135168	; 0x21000
     572:	4298      	cmp	r0, r3
     574:	d0af      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     576:	d907      	bls.n	588 <sysclk_get_peripheral_bus_hz+0x108>
     578:	4b28      	ldr	r3, [pc, #160]	; (61c <sysclk_get_peripheral_bus_hz+0x19c>)
     57a:	4298      	cmp	r0, r3
     57c:	d0ab      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     57e:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     582:	4298      	cmp	r0, r3
     584:	d1ac      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     586:	e7a6      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     588:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
     58c:	4298      	cmp	r0, r3
     58e:	d1a7      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     590:	e7a1      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     592:	4b23      	ldr	r3, [pc, #140]	; (620 <sysclk_get_peripheral_bus_hz+0x1a0>)
     594:	4298      	cmp	r0, r3
     596:	d09e      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     598:	d907      	bls.n	5aa <sysclk_get_peripheral_bus_hz+0x12a>
     59a:	4b22      	ldr	r3, [pc, #136]	; (624 <sysclk_get_peripheral_bus_hz+0x1a4>)
     59c:	4298      	cmp	r0, r3
     59e:	d09a      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5a0:	f503 5380 	add.w	r3, r3, #4096	; 0x1000
     5a4:	4298      	cmp	r0, r3
     5a6:	d19b      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     5a8:	e795      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5aa:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
     5ae:	4298      	cmp	r0, r3
     5b0:	d196      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     5b2:	e790      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5b4:	f5a3 4378 	sub.w	r3, r3, #63488	; 0xf800
     5b8:	4298      	cmp	r0, r3
     5ba:	d08c      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5bc:	d907      	bls.n	5ce <sysclk_get_peripheral_bus_hz+0x14e>
     5be:	4b1a      	ldr	r3, [pc, #104]	; (628 <sysclk_get_peripheral_bus_hz+0x1a8>)
     5c0:	4298      	cmp	r0, r3
     5c2:	d088      	beq.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5c4:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     5c8:	4298      	cmp	r0, r3
     5ca:	d189      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     5cc:	e783      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5ce:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
     5d2:	4298      	cmp	r0, r3
     5d4:	d184      	bne.n	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     5d6:	e77e      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5d8:	4b14      	ldr	r3, [pc, #80]	; (62c <sysclk_get_peripheral_bus_hz+0x1ac>)
     5da:	4298      	cmp	r0, r3
     5dc:	f43f af7b 	beq.w	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5e0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     5e4:	4298      	cmp	r0, r3
     5e6:	f47f af7b 	bne.w	4e0 <sysclk_get_peripheral_bus_hz+0x60>
     5ea:	e774      	b.n	4d6 <sysclk_get_peripheral_bus_hz+0x56>
     5ec:	40078000 	.word	0x40078000
     5f0:	40040000 	.word	0x40040000
     5f4:	40068000 	.word	0x40068000
     5f8:	40010000 	.word	0x40010000
     5fc:	00b71b00 	.word	0x00b71b00
     600:	4001c000 	.word	0x4001c000
     604:	4001c400 	.word	0x4001c400
     608:	40038000 	.word	0x40038000
     60c:	4006c000 	.word	0x4006c000
     610:	400e0000 	.word	0x400e0000
     614:	400f0000 	.word	0x400f0000
     618:	400f0c00 	.word	0x400f0c00
     61c:	400a0000 	.word	0x400a0000
     620:	400a4000 	.word	0x400a4000
     624:	400a5000 	.word	0x400a5000
     628:	400e0c00 	.word	0x400e0c00
     62c:	400f1000 	.word	0x400f1000

00000630 <sysclk_enable_peripheral_clock>:
 *  has an associated clock on the HSB bus, this will be enabled also.
 *
 * \param module Pointer to the module's base address.
 */
void sysclk_enable_peripheral_clock(const volatile void *module)
{
     630:	b508      	push	{r3, lr}
	switch ((uintptr_t)module) {
     632:	4bae      	ldr	r3, [pc, #696]	; (8ec <sysclk_enable_peripheral_clock+0x2bc>)
     634:	4298      	cmp	r0, r3
     636:	f000 81a0 	beq.w	97a <sysclk_enable_peripheral_clock+0x34a>
     63a:	d924      	bls.n	686 <sysclk_enable_peripheral_clock+0x56>
     63c:	4bac      	ldr	r3, [pc, #688]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     63e:	4298      	cmp	r0, r3
     640:	f000 81c3 	beq.w	9ca <sysclk_enable_peripheral_clock+0x39a>
     644:	f200 80e6 	bhi.w	814 <sysclk_enable_peripheral_clock+0x1e4>
     648:	f5a3 337c 	sub.w	r3, r3, #258048	; 0x3f000
     64c:	4298      	cmp	r0, r3
     64e:	f000 81a4 	beq.w	99a <sysclk_enable_peripheral_clock+0x36a>
     652:	f240 80b0 	bls.w	7b6 <sysclk_enable_peripheral_clock+0x186>
     656:	4ba7      	ldr	r3, [pc, #668]	; (8f4 <sysclk_enable_peripheral_clock+0x2c4>)
     658:	4298      	cmp	r0, r3
     65a:	f000 81aa 	beq.w	9b2 <sysclk_enable_peripheral_clock+0x382>
     65e:	f200 80cb 	bhi.w	7f8 <sysclk_enable_peripheral_clock+0x1c8>
     662:	f5a3 5340 	sub.w	r3, r3, #12288	; 0x3000
     666:	4298      	cmp	r0, r3
     668:	f000 819b 	beq.w	9a2 <sysclk_enable_peripheral_clock+0x372>
     66c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
     670:	4298      	cmp	r0, r3
     672:	f040 80c0 	bne.w	7f6 <sysclk_enable_peripheral_clock+0x1c6>
     676:	2104      	movs	r1, #4
     678:	2001      	movs	r0, #1
     67a:	4b9f      	ldr	r3, [pc, #636]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     67c:	4798      	blx	r3
		sysclk_enable_pbb_module(SYSCLK_PDCA_PB);
		break;

	case CRCCU_ADDR:
		sysclk_enable_hsb_module(SYSCLK_CRCCU_DATA);
		sysclk_enable_pbb_module(SYSCLK_CRCCU_REGS);
     67e:	2004      	movs	r0, #4
     680:	4b9e      	ldr	r3, [pc, #632]	; (8fc <sysclk_enable_peripheral_clock+0x2cc>)
     682:	4798      	blx	r3
		break;
     684:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     686:	f5a3 23a0 	sub.w	r3, r3, #327680	; 0x50000
     68a:	4298      	cmp	r0, r3
     68c:	f000 8122 	beq.w	8d4 <sysclk_enable_peripheral_clock+0x2a4>
     690:	d916      	bls.n	6c0 <sysclk_enable_peripheral_clock+0x90>
     692:	4b9b      	ldr	r3, [pc, #620]	; (900 <sysclk_enable_peripheral_clock+0x2d0>)
     694:	4298      	cmp	r0, r3
     696:	f000 8160 	beq.w	95a <sysclk_enable_peripheral_clock+0x32a>
     69a:	d95b      	bls.n	754 <sysclk_enable_peripheral_clock+0x124>
     69c:	4b99      	ldr	r3, [pc, #612]	; (904 <sysclk_enable_peripheral_clock+0x2d4>)
     69e:	4298      	cmp	r0, r3
     6a0:	f000 8163 	beq.w	96a <sysclk_enable_peripheral_clock+0x33a>
     6a4:	d87a      	bhi.n	79c <sysclk_enable_peripheral_clock+0x16c>
     6a6:	f5a3 4300 	sub.w	r3, r3, #32768	; 0x8000
     6aa:	4298      	cmp	r0, r3
     6ac:	f000 8159 	beq.w	962 <sysclk_enable_peripheral_clock+0x332>
     6b0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     6b4:	4298      	cmp	r0, r3
     6b6:	d170      	bne.n	79a <sysclk_enable_peripheral_clock+0x16a>
		sysclk_enable_pba_module(SYSCLK_ABDACB);
     6b8:	2010      	movs	r0, #16
     6ba:	4b93      	ldr	r3, [pc, #588]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     6bc:	4798      	blx	r3
		break;
     6be:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     6c0:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     6c4:	4298      	cmp	r0, r3
     6c6:	f000 80f9 	beq.w	8bc <sysclk_enable_peripheral_clock+0x28c>
     6ca:	d821      	bhi.n	710 <sysclk_enable_peripheral_clock+0xe0>
     6cc:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     6d0:	4298      	cmp	r0, r3
     6d2:	f000 80e4 	beq.w	89e <sysclk_enable_peripheral_clock+0x26e>
     6d6:	d912      	bls.n	6fe <sysclk_enable_peripheral_clock+0xce>
     6d8:	4b8c      	ldr	r3, [pc, #560]	; (90c <sysclk_enable_peripheral_clock+0x2dc>)
     6da:	4298      	cmp	r0, r3
     6dc:	f000 80e3 	beq.w	8a6 <sysclk_enable_peripheral_clock+0x276>
     6e0:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     6e4:	4298      	cmp	r0, r3
     6e6:	d112      	bne.n	70e <sysclk_enable_peripheral_clock+0xde>
		sysclk_enable_pba_module(SYSCLK_TC1);
     6e8:	2003      	movs	r0, #3
     6ea:	4b87      	ldr	r3, [pc, #540]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     6ec:	4798      	blx	r3
 */
static inline void sysclk_enable_pba_divmask(uint32_t mask)
{
	uint32_t temp_mask;

	temp_mask = PM->PM_PBADIVMASK;
     6ee:	4b80      	ldr	r3, [pc, #512]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     6f0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     6f2:	f042 0255 	orr.w	r2, r2, #85	; 0x55
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     6f6:	4986      	ldr	r1, [pc, #536]	; (910 <sysclk_enable_peripheral_clock+0x2e0>)
     6f8:	6599      	str	r1, [r3, #88]	; 0x58
			| PM_UNLOCK_ADDR((uint32_t)&PM->PM_PBADIVMASK - (uint32_t)PM);
	PM->PM_PBADIVMASK = temp_mask;
     6fa:	641a      	str	r2, [r3, #64]	; 0x40
     6fc:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     6fe:	f1b0 2f40 	cmp.w	r0, #1073758208	; 0x40004000
     702:	d103      	bne.n	70c <sysclk_enable_peripheral_clock+0xdc>
		sysclk_enable_pba_module(SYSCLK_IISC);
     704:	2000      	movs	r0, #0
     706:	4b80      	ldr	r3, [pc, #512]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     708:	4798      	blx	r3
		break;
     70a:	bd08      	pop	{r3, pc}
     70c:	bd08      	pop	{r3, pc}
     70e:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     710:	4b80      	ldr	r3, [pc, #512]	; (914 <sysclk_enable_peripheral_clock+0x2e4>)
     712:	4298      	cmp	r0, r3
     714:	f000 80d6 	beq.w	8c4 <sysclk_enable_peripheral_clock+0x294>
     718:	d912      	bls.n	740 <sysclk_enable_peripheral_clock+0x110>
     71a:	4b7f      	ldr	r3, [pc, #508]	; (918 <sysclk_enable_peripheral_clock+0x2e8>)
     71c:	4298      	cmp	r0, r3
     71e:	f000 80d5 	beq.w	8cc <sysclk_enable_peripheral_clock+0x29c>
     722:	f503 43f8 	add.w	r3, r3, #31744	; 0x7c00
     726:	4298      	cmp	r0, r3
     728:	d113      	bne.n	752 <sysclk_enable_peripheral_clock+0x122>
		sysclk_enable_pba_module(SYSCLK_USART0);
     72a:	2008      	movs	r0, #8
     72c:	4b76      	ldr	r3, [pc, #472]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     72e:	4798      	blx	r3
	temp_mask = PM->PM_PBADIVMASK;
     730:	4b6f      	ldr	r3, [pc, #444]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     732:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     734:	f042 0204 	orr.w	r2, r2, #4
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     738:	4975      	ldr	r1, [pc, #468]	; (910 <sysclk_enable_peripheral_clock+0x2e0>)
     73a:	6599      	str	r1, [r3, #88]	; 0x58
	PM->PM_PBADIVMASK = temp_mask;
     73c:	641a      	str	r2, [r3, #64]	; 0x40
     73e:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     740:	f5a3 5370 	sub.w	r3, r3, #15360	; 0x3c00
     744:	4298      	cmp	r0, r3
     746:	d103      	bne.n	750 <sysclk_enable_peripheral_clock+0x120>
		sysclk_enable_pba_module(SYSCLK_TWIS0);
     748:	2005      	movs	r0, #5
     74a:	4b6f      	ldr	r3, [pc, #444]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     74c:	4798      	blx	r3
		break;
     74e:	bd08      	pop	{r3, pc}
     750:	bd08      	pop	{r3, pc}
     752:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     754:	f5a3 3380 	sub.w	r3, r3, #65536	; 0x10000
     758:	4298      	cmp	r0, r3
     75a:	f000 80ef 	beq.w	93c <sysclk_enable_peripheral_clock+0x30c>
     75e:	d90b      	bls.n	778 <sysclk_enable_peripheral_clock+0x148>
     760:	4b6e      	ldr	r3, [pc, #440]	; (91c <sysclk_enable_peripheral_clock+0x2ec>)
     762:	4298      	cmp	r0, r3
     764:	f000 80f5 	beq.w	952 <sysclk_enable_peripheral_clock+0x322>
     768:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     76c:	4298      	cmp	r0, r3
     76e:	d113      	bne.n	798 <sysclk_enable_peripheral_clock+0x168>
		sysclk_enable_pba_module(SYSCLK_DACC);
     770:	200d      	movs	r0, #13
     772:	4b65      	ldr	r3, [pc, #404]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     774:	4798      	blx	r3
		break;
     776:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     778:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
     77c:	4298      	cmp	r0, r3
     77e:	d10a      	bne.n	796 <sysclk_enable_peripheral_clock+0x166>
		sysclk_enable_pba_module(SYSCLK_USART2);
     780:	200a      	movs	r0, #10
     782:	4b61      	ldr	r3, [pc, #388]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     784:	4798      	blx	r3
	temp_mask = PM->PM_PBADIVMASK;
     786:	4b5a      	ldr	r3, [pc, #360]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     788:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     78a:	f042 0204 	orr.w	r2, r2, #4
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     78e:	4960      	ldr	r1, [pc, #384]	; (910 <sysclk_enable_peripheral_clock+0x2e0>)
     790:	6599      	str	r1, [r3, #88]	; 0x58
	PM->PM_PBADIVMASK = temp_mask;
     792:	641a      	str	r2, [r3, #64]	; 0x40
     794:	bd08      	pop	{r3, pc}
     796:	bd08      	pop	{r3, pc}
     798:	bd08      	pop	{r3, pc}
     79a:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     79c:	4b60      	ldr	r3, [pc, #384]	; (920 <sysclk_enable_peripheral_clock+0x2f0>)
     79e:	4298      	cmp	r0, r3
     7a0:	f000 80e7 	beq.w	972 <sysclk_enable_peripheral_clock+0x342>
     7a4:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
     7a8:	4298      	cmp	r0, r3
     7aa:	d103      	bne.n	7b4 <sysclk_enable_peripheral_clock+0x184>
		sysclk_enable_pba_module(SYSCLK_CATB);
     7ac:	2013      	movs	r0, #19
     7ae:	4b56      	ldr	r3, [pc, #344]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     7b0:	4798      	blx	r3
		break;
     7b2:	bd08      	pop	{r3, pc}
     7b4:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     7b6:	f5a3 3304 	sub.w	r3, r3, #135168	; 0x21000
     7ba:	4298      	cmp	r0, r3
     7bc:	f000 80e1 	beq.w	982 <sysclk_enable_peripheral_clock+0x352>
     7c0:	d90f      	bls.n	7e2 <sysclk_enable_peripheral_clock+0x1b2>
     7c2:	4b58      	ldr	r3, [pc, #352]	; (924 <sysclk_enable_peripheral_clock+0x2f4>)
     7c4:	4298      	cmp	r0, r3
     7c6:	f000 80e0 	beq.w	98a <sysclk_enable_peripheral_clock+0x35a>
     7ca:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     7ce:	4298      	cmp	r0, r3
     7d0:	d110      	bne.n	7f4 <sysclk_enable_peripheral_clock+0x1c4>
	sysclk_priv_enable_module(PM_CLK_GRP_HSB, module_index);
     7d2:	2102      	movs	r1, #2
     7d4:	2001      	movs	r0, #1
     7d6:	4b48      	ldr	r3, [pc, #288]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     7d8:	4798      	blx	r3
		sysclk_enable_pbb_module(SYSCLK_HRAMC1_REGS);
     7da:	2001      	movs	r0, #1
     7dc:	4b47      	ldr	r3, [pc, #284]	; (8fc <sysclk_enable_peripheral_clock+0x2cc>)
     7de:	4798      	blx	r3
		break;
     7e0:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     7e2:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
     7e6:	4298      	cmp	r0, r3
     7e8:	d103      	bne.n	7f2 <sysclk_enable_peripheral_clock+0x1c2>
		sysclk_enable_pba_module(SYSCLK_TWIM3);
     7ea:	2016      	movs	r0, #22
     7ec:	4b46      	ldr	r3, [pc, #280]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     7ee:	4798      	blx	r3
		break;
     7f0:	bd08      	pop	{r3, pc}
     7f2:	bd08      	pop	{r3, pc}
     7f4:	bd08      	pop	{r3, pc}
     7f6:	bd08      	pop	{r3, pc}
	switch ((uintptr_t)module) {
     7f8:	4b4b      	ldr	r3, [pc, #300]	; (928 <sysclk_enable_peripheral_clock+0x2f8>)
     7fa:	4298      	cmp	r0, r3
     7fc:	f000 80e1 	beq.w	9c2 <sysclk_enable_peripheral_clock+0x392>
     800:	f503 4320 	add.w	r3, r3, #40960	; 0xa000
     804:	4298      	cmp	r0, r3
     806:	d104      	bne.n	812 <sysclk_enable_peripheral_clock+0x1e2>
     808:	2109      	movs	r1, #9
     80a:	2001      	movs	r0, #1
     80c:	4b3a      	ldr	r3, [pc, #232]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     80e:	4798      	blx	r3
     810:	bd08      	pop	{r3, pc}
     812:	bd08      	pop	{r3, pc}
     814:	4b45      	ldr	r3, [pc, #276]	; (92c <sysclk_enable_peripheral_clock+0x2fc>)
     816:	4298      	cmp	r0, r3
     818:	f000 80e6 	beq.w	9e8 <sysclk_enable_peripheral_clock+0x3b8>
     81c:	d912      	bls.n	844 <sysclk_enable_peripheral_clock+0x214>
     81e:	4b44      	ldr	r3, [pc, #272]	; (930 <sysclk_enable_peripheral_clock+0x300>)
     820:	4298      	cmp	r0, r3
     822:	f000 80eb 	beq.w	9fc <sysclk_enable_peripheral_clock+0x3cc>
     826:	d82c      	bhi.n	882 <sysclk_enable_peripheral_clock+0x252>
     828:	f5a3 6300 	sub.w	r3, r3, #2048	; 0x800
     82c:	4298      	cmp	r0, r3
     82e:	f000 80e0 	beq.w	9f2 <sysclk_enable_peripheral_clock+0x3c2>
     832:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     836:	4298      	cmp	r0, r3
     838:	d122      	bne.n	880 <sysclk_enable_peripheral_clock+0x250>
	sysclk_priv_enable_module(PM_CLK_GRP_PBD, module_index);
     83a:	2102      	movs	r1, #2
     83c:	2005      	movs	r0, #5
     83e:	4b2e      	ldr	r3, [pc, #184]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     840:	4798      	blx	r3
     842:	bd08      	pop	{r3, pc}
     844:	f5a3 4378 	sub.w	r3, r3, #63488	; 0xf800
     848:	4298      	cmp	r0, r3
     84a:	f000 80c3 	beq.w	9d4 <sysclk_enable_peripheral_clock+0x3a4>
     84e:	d90c      	bls.n	86a <sysclk_enable_peripheral_clock+0x23a>
     850:	4b38      	ldr	r3, [pc, #224]	; (934 <sysclk_enable_peripheral_clock+0x304>)
     852:	4298      	cmp	r0, r3
     854:	f000 80c3 	beq.w	9de <sysclk_enable_peripheral_clock+0x3ae>
     858:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     85c:	4298      	cmp	r0, r3
     85e:	d10e      	bne.n	87e <sysclk_enable_peripheral_clock+0x24e>
	sysclk_priv_enable_module(PM_CLK_GRP_PBC, module_index);
     860:	2104      	movs	r1, #4
     862:	4608      	mov	r0, r1
     864:	4b24      	ldr	r3, [pc, #144]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     866:	4798      	blx	r3
     868:	bd08      	pop	{r3, pc}
     86a:	f5a3 6380 	sub.w	r3, r3, #1024	; 0x400
     86e:	4298      	cmp	r0, r3
     870:	d104      	bne.n	87c <sysclk_enable_peripheral_clock+0x24c>
     872:	2101      	movs	r1, #1
     874:	2004      	movs	r0, #4
     876:	4b20      	ldr	r3, [pc, #128]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     878:	4798      	blx	r3
     87a:	bd08      	pop	{r3, pc}
     87c:	bd08      	pop	{r3, pc}
     87e:	bd08      	pop	{r3, pc}
     880:	bd08      	pop	{r3, pc}
     882:	4b2d      	ldr	r3, [pc, #180]	; (938 <sysclk_enable_peripheral_clock+0x308>)
     884:	4298      	cmp	r0, r3
     886:	f000 80be 	beq.w	a06 <sysclk_enable_peripheral_clock+0x3d6>
     88a:	f503 6380 	add.w	r3, r3, #1024	; 0x400
     88e:	4298      	cmp	r0, r3
     890:	d104      	bne.n	89c <sysclk_enable_peripheral_clock+0x26c>
	sysclk_priv_enable_module(PM_CLK_GRP_PBD, module_index);
     892:	2105      	movs	r1, #5
     894:	4608      	mov	r0, r1
     896:	4b18      	ldr	r3, [pc, #96]	; (8f8 <sysclk_enable_peripheral_clock+0x2c8>)
     898:	4798      	blx	r3
     89a:	bd08      	pop	{r3, pc}
     89c:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_SPI);
     89e:	2001      	movs	r0, #1
     8a0:	4b19      	ldr	r3, [pc, #100]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8a2:	4798      	blx	r3
		break;
     8a4:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TC0);
     8a6:	2002      	movs	r0, #2
     8a8:	4b17      	ldr	r3, [pc, #92]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8aa:	4798      	blx	r3
	temp_mask = PM->PM_PBADIVMASK;
     8ac:	4b10      	ldr	r3, [pc, #64]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     8ae:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     8b0:	f042 0255 	orr.w	r2, r2, #85	; 0x55
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     8b4:	4916      	ldr	r1, [pc, #88]	; (910 <sysclk_enable_peripheral_clock+0x2e0>)
     8b6:	6599      	str	r1, [r3, #88]	; 0x58
	PM->PM_PBADIVMASK = temp_mask;
     8b8:	641a      	str	r2, [r3, #64]	; 0x40
     8ba:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TWIM0);
     8bc:	2004      	movs	r0, #4
     8be:	4b12      	ldr	r3, [pc, #72]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8c0:	4798      	blx	r3
		break;
     8c2:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TWIM1);
     8c4:	2006      	movs	r0, #6
     8c6:	4b10      	ldr	r3, [pc, #64]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8c8:	4798      	blx	r3
		break;
     8ca:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TWIS1);
     8cc:	2007      	movs	r0, #7
     8ce:	4b0e      	ldr	r3, [pc, #56]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8d0:	4798      	blx	r3
		break;
     8d2:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_USART1);
     8d4:	2009      	movs	r0, #9
     8d6:	4b0c      	ldr	r3, [pc, #48]	; (908 <sysclk_enable_peripheral_clock+0x2d8>)
     8d8:	4798      	blx	r3
	temp_mask = PM->PM_PBADIVMASK;
     8da:	4b05      	ldr	r3, [pc, #20]	; (8f0 <sysclk_enable_peripheral_clock+0x2c0>)
     8dc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     8de:	f042 0204 	orr.w	r2, r2, #4
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     8e2:	490b      	ldr	r1, [pc, #44]	; (910 <sysclk_enable_peripheral_clock+0x2e0>)
     8e4:	6599      	str	r1, [r3, #88]	; 0x58
	PM->PM_PBADIVMASK = temp_mask;
     8e6:	641a      	str	r2, [r3, #64]	; 0x40
     8e8:	bd08      	pop	{r3, pc}
     8ea:	bf00      	nop
     8ec:	40078000 	.word	0x40078000
     8f0:	400e0000 	.word	0x400e0000
     8f4:	400a5000 	.word	0x400a5000
     8f8:	00000371 	.word	0x00000371
     8fc:	00000429 	.word	0x00000429
     900:	40040000 	.word	0x40040000
     904:	40068000 	.word	0x40068000
     908:	000003d1 	.word	0x000003d1
     90c:	40010000 	.word	0x40010000
     910:	aa000040 	.word	0xaa000040
     914:	4001c000 	.word	0x4001c000
     918:	4001c400 	.word	0x4001c400
     91c:	40038000 	.word	0x40038000
     920:	4006c000 	.word	0x4006c000
     924:	400a0000 	.word	0x400a0000
     928:	400a6000 	.word	0x400a6000
     92c:	400f0000 	.word	0x400f0000
     930:	400f0c00 	.word	0x400f0c00
     934:	400e0c00 	.word	0x400e0c00
     938:	400f1000 	.word	0x400f1000
		sysclk_enable_pba_module(SYSCLK_USART3);
     93c:	200b      	movs	r0, #11
     93e:	4b34      	ldr	r3, [pc, #208]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     940:	4798      	blx	r3
	temp_mask = PM->PM_PBADIVMASK;
     942:	4b34      	ldr	r3, [pc, #208]	; (a14 <sysclk_enable_peripheral_clock+0x3e4>)
     944:	6c1a      	ldr	r2, [r3, #64]	; 0x40
	temp_mask |= mask;
     946:	f042 0204 	orr.w	r2, r2, #4
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     94a:	4933      	ldr	r1, [pc, #204]	; (a18 <sysclk_enable_peripheral_clock+0x3e8>)
     94c:	6599      	str	r1, [r3, #88]	; 0x58
	PM->PM_PBADIVMASK = temp_mask;
     94e:	641a      	str	r2, [r3, #64]	; 0x40
     950:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_ADCIFE);
     952:	200c      	movs	r0, #12
     954:	4b2e      	ldr	r3, [pc, #184]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     956:	4798      	blx	r3
		break;
     958:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_ACIFC);
     95a:	200e      	movs	r0, #14
     95c:	4b2c      	ldr	r3, [pc, #176]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     95e:	4798      	blx	r3
		break;
     960:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_GLOC);
     962:	200f      	movs	r0, #15
     964:	4b2a      	ldr	r3, [pc, #168]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     966:	4798      	blx	r3
		break;
     968:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TRNG);
     96a:	2011      	movs	r0, #17
     96c:	4b28      	ldr	r3, [pc, #160]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     96e:	4798      	blx	r3
		break;
     970:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_PARC);
     972:	2012      	movs	r0, #18
     974:	4b26      	ldr	r3, [pc, #152]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     976:	4798      	blx	r3
		break;
     978:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_TWIM2);
     97a:	2015      	movs	r0, #21
     97c:	4b24      	ldr	r3, [pc, #144]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     97e:	4798      	blx	r3
		break;
     980:	bd08      	pop	{r3, pc}
		sysclk_enable_pba_module(SYSCLK_LCDCA);
     982:	2017      	movs	r0, #23
     984:	4b22      	ldr	r3, [pc, #136]	; (a10 <sysclk_enable_peripheral_clock+0x3e0>)
     986:	4798      	blx	r3
		break;
     988:	bd08      	pop	{r3, pc}
	sysclk_priv_enable_module(PM_CLK_GRP_HSB, module_index);
     98a:	2101      	movs	r1, #1
     98c:	4608      	mov	r0, r1
     98e:	4b23      	ldr	r3, [pc, #140]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     990:	4798      	blx	r3
		sysclk_enable_pbb_module(SYSCLK_HFLASHC_REGS);
     992:	2000      	movs	r0, #0
     994:	4b22      	ldr	r3, [pc, #136]	; (a20 <sysclk_enable_peripheral_clock+0x3f0>)
     996:	4798      	blx	r3
		break;
     998:	bd08      	pop	{r3, pc}
		sysclk_enable_pbb_module(SYSCLK_HMATRIX);
     99a:	2002      	movs	r0, #2
     99c:	4b20      	ldr	r3, [pc, #128]	; (a20 <sysclk_enable_peripheral_clock+0x3f0>)
     99e:	4798      	blx	r3
		break;
     9a0:	bd08      	pop	{r3, pc}
     9a2:	2100      	movs	r1, #0
     9a4:	2001      	movs	r0, #1
     9a6:	4b1d      	ldr	r3, [pc, #116]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9a8:	4798      	blx	r3
		sysclk_enable_pbb_module(SYSCLK_PDCA_PB);
     9aa:	2003      	movs	r0, #3
     9ac:	4b1c      	ldr	r3, [pc, #112]	; (a20 <sysclk_enable_peripheral_clock+0x3f0>)
     9ae:	4798      	blx	r3
		break;
     9b0:	bd08      	pop	{r3, pc}
     9b2:	2103      	movs	r1, #3
     9b4:	2001      	movs	r0, #1
     9b6:	4b19      	ldr	r3, [pc, #100]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9b8:	4798      	blx	r3

	case USBC_ADDR:
		sysclk_enable_hsb_module(SYSCLK_USBC_DATA);
		sysclk_enable_pbb_module(SYSCLK_USBC_REGS);
     9ba:	2005      	movs	r0, #5
     9bc:	4b18      	ldr	r3, [pc, #96]	; (a20 <sysclk_enable_peripheral_clock+0x3f0>)
     9be:	4798      	blx	r3
		break;
     9c0:	bd08      	pop	{r3, pc}

	case PEVC_ADDR:
		sysclk_enable_pbb_module(SYSCLK_PEVC);
     9c2:	2006      	movs	r0, #6
     9c4:	4b16      	ldr	r3, [pc, #88]	; (a20 <sysclk_enable_peripheral_clock+0x3f0>)
     9c6:	4798      	blx	r3
		break;
     9c8:	bd08      	pop	{r3, pc}
	sysclk_priv_enable_module(PM_CLK_GRP_PBC, module_index);
     9ca:	2100      	movs	r1, #0
     9cc:	2004      	movs	r0, #4
     9ce:	4b13      	ldr	r3, [pc, #76]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9d0:	4798      	blx	r3
     9d2:	bd08      	pop	{r3, pc}
     9d4:	2102      	movs	r1, #2
     9d6:	2004      	movs	r0, #4
     9d8:	4b10      	ldr	r3, [pc, #64]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9da:	4798      	blx	r3
     9dc:	bd08      	pop	{r3, pc}
     9de:	2103      	movs	r1, #3
     9e0:	2004      	movs	r0, #4
     9e2:	4b0e      	ldr	r3, [pc, #56]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9e4:	4798      	blx	r3
     9e6:	bd08      	pop	{r3, pc}
	sysclk_priv_enable_module(PM_CLK_GRP_PBD, module_index);
     9e8:	2100      	movs	r1, #0
     9ea:	2005      	movs	r0, #5
     9ec:	4b0b      	ldr	r3, [pc, #44]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9ee:	4798      	blx	r3
     9f0:	bd08      	pop	{r3, pc}
     9f2:	2101      	movs	r1, #1
     9f4:	2005      	movs	r0, #5
     9f6:	4b09      	ldr	r3, [pc, #36]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     9f8:	4798      	blx	r3
     9fa:	bd08      	pop	{r3, pc}
     9fc:	2103      	movs	r1, #3
     9fe:	2005      	movs	r0, #5
     a00:	4b06      	ldr	r3, [pc, #24]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     a02:	4798      	blx	r3
     a04:	bd08      	pop	{r3, pc}
     a06:	2104      	movs	r1, #4
     a08:	2005      	movs	r0, #5
     a0a:	4b04      	ldr	r3, [pc, #16]	; (a1c <sysclk_enable_peripheral_clock+0x3ec>)
     a0c:	4798      	blx	r3
     a0e:	bd08      	pop	{r3, pc}
     a10:	000003d1 	.word	0x000003d1
     a14:	400e0000 	.word	0x400e0000
     a18:	aa000040 	.word	0xaa000040
     a1c:	00000371 	.word	0x00000371
     a20:	00000429 	.word	0x00000429

00000a24 <sysclk_set_source>:
 *
 * \param src The new system clock source. Must be one of the constants
 * from the <em>System Clock Sources</em> section.
 */
void sysclk_set_source(uint32_t src)
{
     a24:	b082      	sub	sp, #8
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     a26:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
     a2a:	fab3 f383 	clz	r3, r3
     a2e:	095b      	lsrs	r3, r3, #5
     a30:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     a32:	b672      	cpsid	i
     a34:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     a38:	2200      	movs	r2, #0
     a3a:	4b08      	ldr	r3, [pc, #32]	; (a5c <sysclk_set_source+0x38>)
     a3c:	701a      	strb	r2, [r3, #0]
	return flags;
     a3e:	9a01      	ldr	r2, [sp, #4]
	irqflags_t flags;
	Assert(src <= SYSCLK_SRC_RC1M);

	flags = cpu_irq_save();
	PM->PM_UNLOCK = PM_UNLOCK_KEY(0xAAu)
     a40:	4b07      	ldr	r3, [pc, #28]	; (a60 <sysclk_set_source+0x3c>)
     a42:	f04f 412a 	mov.w	r1, #2852126720	; 0xaa000000
     a46:	6599      	str	r1, [r3, #88]	; 0x58
		| PM_UNLOCK_ADDR((uint32_t)&PM->PM_MCCTRL - (uint32_t)PM);
	PM->PM_MCCTRL = src;
     a48:	6018      	str	r0, [r3, #0]
	if (cpu_irq_is_enabled_flags(flags))
     a4a:	b12a      	cbz	r2, a58 <sysclk_set_source+0x34>
		cpu_irq_enable();
     a4c:	2201      	movs	r2, #1
     a4e:	4b03      	ldr	r3, [pc, #12]	; (a5c <sysclk_set_source+0x38>)
     a50:	701a      	strb	r2, [r3, #0]
     a52:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     a56:	b662      	cpsie	i
	cpu_irq_restore(flags);
}
     a58:	b002      	add	sp, #8
     a5a:	4770      	bx	lr
     a5c:	20000030 	.word	0x20000030
     a60:	400e0000 	.word	0x400e0000

00000a64 <sysclk_init>:
   genclk_disable(7);
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
     a64:	b530      	push	{r4, r5, lr}
     a66:	b083      	sub	sp, #12
	uint32_t ps_value = 0;
	bool is_fwu_enabled = false;

#if CONFIG_HCACHE_ENABLE == 1
	/* Enable HCACHE */
	sysclk_enable_peripheral_clock(HCACHE);
     a68:	4c1d      	ldr	r4, [pc, #116]	; (ae0 <sysclk_init+0x7c>)
     a6a:	4620      	mov	r0, r4
     a6c:	4b1d      	ldr	r3, [pc, #116]	; (ae4 <sysclk_init+0x80>)
     a6e:	4798      	blx	r3
	HCACHE->HCACHE_CTRL = HCACHE_CTRL_CEN_YES;
     a70:	2301      	movs	r3, #1
     a72:	60a3      	str	r3, [r4, #8]
	while (!(HCACHE->HCACHE_SR & HCACHE_SR_CSTS_EN));
     a74:	4622      	mov	r2, r4
     a76:	68d3      	ldr	r3, [r2, #12]
     a78:	f013 0f01 	tst.w	r3, #1
     a7c:	d0fb      	beq.n	a76 <sysclk_init+0x12>
static inline void osc_enable(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		osc_priv_enable_osc0();
     a7e:	4b1a      	ldr	r3, [pc, #104]	; (ae8 <sysclk_init+0x84>)
     a80:	4798      	blx	r3
static inline bool osc_is_ready(uint8_t id)
{
	switch (id) {
#ifdef BOARD_OSC0_HZ
	case OSC_ID_OSC0:
		return !!(SCIF->SCIF_PCLKSR & SCIF_PCLKSR_OSC0RDY);
     a82:	4a1a      	ldr	r2, [pc, #104]	; (aec <sysclk_init+0x88>)
     a84:	6953      	ldr	r3, [r2, #20]
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
     a86:	f013 0f01 	tst.w	r3, #1
     a8a:	d0fb      	beq.n	a84 <sysclk_init+0x20>
#ifdef BOARD_OSC0_HZ
	else if (CONFIG_SYSCLK_SOURCE == SYSCLK_SRC_OSC0) {
		osc_enable(OSC_ID_OSC0);
		osc_wait_ready(OSC_ID_OSC0);
		// Set a flash wait state depending on the new cpu frequency.
		flash_set_bus_freq(sysclk_get_cpu_hz(), ps_value, is_fwu_enabled);
     a8c:	2200      	movs	r2, #0
     a8e:	4611      	mov	r1, r2
     a90:	4817      	ldr	r0, [pc, #92]	; (af0 <sysclk_init+0x8c>)
     a92:	4b18      	ldr	r3, [pc, #96]	; (af4 <sysclk_init+0x90>)
     a94:	4798      	blx	r3
		sysclk_set_source(SYSCLK_SRC_OSC0);
     a96:	2001      	movs	r0, #1
     a98:	4b17      	ldr	r3, [pc, #92]	; (af8 <sysclk_init+0x94>)
     a9a:	4798      	blx	r3
	if (!no_halt) {
		bpm_power_scaling_cpu(bpm, ps_value);
		return true;
	}

	return bpm_power_scaling_cpu_failsafe(bpm, ps_value, 240000);
     a9c:	4a17      	ldr	r2, [pc, #92]	; (afc <sysclk_init+0x98>)
     a9e:	2100      	movs	r1, #0
     aa0:	4817      	ldr	r0, [pc, #92]	; (b00 <sysclk_init+0x9c>)
     aa2:	4b18      	ldr	r3, [pc, #96]	; (b04 <sysclk_init+0xa0>)
     aa4:	4798      	blx	r3
		Assert(false);
	}

	/* Automatically switch to low power mode */
	bpm_configure_power_scaling(BPM, ps_value, BPM_PSCM_CPU_NOT_HALT);
	while ((bpm_get_status(BPM) & BPM_SR_PSOK) == 0);
     aa6:	4d16      	ldr	r5, [pc, #88]	; (b00 <sysclk_init+0x9c>)
     aa8:	4c17      	ldr	r4, [pc, #92]	; (b08 <sysclk_init+0xa4>)
     aaa:	4628      	mov	r0, r5
     aac:	47a0      	blx	r4
     aae:	f010 0f01 	tst.w	r0, #1
     ab2:	d0fa      	beq.n	aaa <sysclk_init+0x46>
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     ab4:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
     ab8:	fab3 f383 	clz	r3, r3
     abc:	095b      	lsrs	r3, r3, #5
     abe:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     ac0:	b672      	cpsid	i
     ac2:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     ac6:	2200      	movs	r2, #0
     ac8:	4b10      	ldr	r3, [pc, #64]	; (b0c <sysclk_init+0xa8>)
     aca:	701a      	strb	r2, [r3, #0]
	return flags;
     acc:	9b01      	ldr	r3, [sp, #4]
	if (cpu_irq_is_enabled_flags(flags))
     ace:	b12b      	cbz	r3, adc <sysclk_init+0x78>
		cpu_irq_enable();
     ad0:	2201      	movs	r2, #1
     ad2:	4b0e      	ldr	r3, [pc, #56]	; (b0c <sysclk_init+0xa8>)
     ad4:	701a      	strb	r2, [r3, #0]
     ad6:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     ada:	b662      	cpsie	i

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = true;
#endif
}
     adc:	b003      	add	sp, #12
     ade:	bd30      	pop	{r4, r5, pc}
     ae0:	400a0400 	.word	0x400a0400
     ae4:	00000631 	.word	0x00000631
     ae8:	00000329 	.word	0x00000329
     aec:	400e0800 	.word	0x400e0800
     af0:	00b71b00 	.word	0x00b71b00
     af4:	00000c19 	.word	0x00000c19
     af8:	00000a25 	.word	0x00000a25
     afc:	0003a980 	.word	0x0003a980
     b00:	400f0000 	.word	0x400f0000
     b04:	00000b11 	.word	0x00000b11
     b08:	00000b85 	.word	0x00000b85
     b0c:	20000030 	.word	0x20000030

00000b10 <bpm_power_scaling_cpu_failsafe>:
}


bool bpm_power_scaling_cpu_failsafe(Bpm *bpm, uint32_t ps_value,
	uint32_t timeout)
{
     b10:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
     b14:	b083      	sub	sp, #12
	uint32_t pmcon = 0;

	/* Read last PM_CON value */
	pmcon = bpm->BPM_PMCON;
     b16:	69c3      	ldr	r3, [r0, #28]

	/* Clear last PS Value & Write new one */
	pmcon &= ~BPM_PMCON_PS_Msk;
     b18:	f023 0e03 	bic.w	lr, r3, #3
  __ASM volatile ("MRS %0, primask" : "=r" (result) );
     b1c:	f3ef 8310 	mrs	r3, PRIMASK
	volatile irqflags_t flags = cpu_irq_is_enabled();
     b20:	fab3 f383 	clz	r3, r3
     b24:	095b      	lsrs	r3, r3, #5
     b26:	9301      	str	r3, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
     b28:	b672      	cpsid	i
     b2a:	f3bf 8f5f 	dmb	sy
	cpu_irq_disable();
     b2e:	2500      	movs	r5, #0
     b30:	4b11      	ldr	r3, [pc, #68]	; (b78 <bpm_power_scaling_cpu_failsafe+0x68>)
     b32:	701d      	strb	r5, [r3, #0]
	return flags;
     b34:	9e01      	ldr	r6, [sp, #4]
	uint32_t ctrl, load, val;
	/* Avoid interrupt while flash halt */
	flags = cpu_irq_save();

	/* Save SysTick */
	val = SysTick->VAL;
     b36:	4c11      	ldr	r4, [pc, #68]	; (b7c <bpm_power_scaling_cpu_failsafe+0x6c>)
     b38:	f8d4 8008 	ldr.w	r8, [r4, #8]
	ctrl = SysTick->CTRL;
     b3c:	6827      	ldr	r7, [r4, #0]
	load = SysTick->LOAD;
     b3e:	f8d4 9004 	ldr.w	r9, [r4, #4]
	/* Setup SysTick & start counting */
	SysTick->LOAD = timeout;
     b42:	6062      	str	r2, [r4, #4]
	SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
     b44:	2305      	movs	r3, #5
     b46:	6023      	str	r3, [r4, #0]
	pmcon |= BPM_PMCON_PS(ps_value);
     b48:	f001 0103 	and.w	r1, r1, #3
	pmcon |= BPM_PMCON_PSCREQ;
     b4c:	f041 010c 	orr.w	r1, r1, #12

	b_psok = bpm_ps_no_halt_exec(bpm, pmcon);
     b50:	ea41 010e 	orr.w	r1, r1, lr
     b54:	4b0a      	ldr	r3, [pc, #40]	; (b80 <bpm_power_scaling_cpu_failsafe+0x70>)
     b56:	4798      	blx	r3

	/* Restore SysTick */
	SysTick->CTRL = 0;
     b58:	6025      	str	r5, [r4, #0]
	SysTick->LOAD = load;
     b5a:	f8c4 9004 	str.w	r9, [r4, #4]
	SysTick->VAL = val;
     b5e:	f8c4 8008 	str.w	r8, [r4, #8]
	SysTick->CTRL = ctrl;
     b62:	6027      	str	r7, [r4, #0]
	if (cpu_irq_is_enabled_flags(flags))
     b64:	b12e      	cbz	r6, b72 <bpm_power_scaling_cpu_failsafe+0x62>
		cpu_irq_enable();
     b66:	2201      	movs	r2, #1
     b68:	4b03      	ldr	r3, [pc, #12]	; (b78 <bpm_power_scaling_cpu_failsafe+0x68>)
     b6a:	701a      	strb	r2, [r3, #0]
     b6c:	f3bf 8f5f 	dmb	sy
  __ASM volatile ("cpsie i" : : : "memory");
     b70:	b662      	cpsie	i

	cpu_irq_restore(flags);
	return b_psok;
}
     b72:	b003      	add	sp, #12
     b74:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
     b78:	20000030 	.word	0x20000030
     b7c:	e000e010 	.word	0xe000e010
     b80:	20000001 	.word	0x20000001

00000b84 <bpm_get_status>:
	bpm->BPM_ICR = sources;
}

uint32_t bpm_get_status(Bpm *bpm)
{
	return bpm->BPM_SR;
     b84:	6940      	ldr	r0, [r0, #20]
}
     b86:	4770      	bx	lr

00000b88 <flashcalw_set_wait_state>:
 * \param wait_state The number of wait states of flash read accesses: \c 0 to
 *                   \c 1.
 */
void flashcalw_set_wait_state(uint32_t wait_state)
{
	HFLASHC->FLASHCALW_FCR = (HFLASHC->FLASHCALW_FCR & ~FLASHCALW_FCR_FWS)
     b88:	4b05      	ldr	r3, [pc, #20]	; (ba0 <flashcalw_set_wait_state+0x18>)
     b8a:	681a      	ldr	r2, [r3, #0]
     b8c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
			| (wait_state ? FLASHCALW_FCR_FWS_1 :
     b90:	2800      	cmp	r0, #0
     b92:	bf14      	ite	ne
     b94:	2340      	movne	r3, #64	; 0x40
     b96:	2300      	moveq	r3, #0
     b98:	4313      	orrs	r3, r2
	HFLASHC->FLASHCALW_FCR = (HFLASHC->FLASHCALW_FCR & ~FLASHCALW_FCR_FWS)
     b9a:	4a01      	ldr	r2, [pc, #4]	; (ba0 <flashcalw_set_wait_state+0x18>)
     b9c:	6013      	str	r3, [r2, #0]
     b9e:	4770      	bx	lr
     ba0:	400a0000 	.word	0x400a0000

00000ba4 <flashcalw_is_ready>:
 *
 * \return Whether the FLASHCALW is ready to run a new command.
 */
bool flashcalw_is_ready(void)
{
	return ((HFLASHC->FLASHCALW_FSR & FLASHCALW_FSR_FRDY) != 0);
     ba4:	4b02      	ldr	r3, [pc, #8]	; (bb0 <flashcalw_is_ready+0xc>)
     ba6:	6898      	ldr	r0, [r3, #8]
}
     ba8:	f000 0001 	and.w	r0, r0, #1
     bac:	4770      	bx	lr
     bae:	bf00      	nop
     bb0:	400a0000 	.word	0x400a0000

00000bb4 <flashcalw_default_wait_until_ready>:
/*! \brief Waits actively until the FLASHCALW is ready to run a new command.
 *
 * This is the default function assigned to \ref flashcalw_wait_until_ready.
 */
void flashcalw_default_wait_until_ready(void)
{
     bb4:	b510      	push	{r4, lr}
	while (!flashcalw_is_ready()) {
     bb6:	4c02      	ldr	r4, [pc, #8]	; (bc0 <flashcalw_default_wait_until_ready+0xc>)
     bb8:	47a0      	blx	r4
     bba:	2800      	cmp	r0, #0
     bbc:	d0fc      	beq.n	bb8 <flashcalw_default_wait_until_ready+0x4>
	}
}
     bbe:	bd10      	pop	{r4, pc}
     bc0:	00000ba5 	.word	0x00000ba5

00000bc4 <flashcalw_issue_command>:
 *
 * \note The FLASHCALW error status returned by \ref flashcalw_is_lock_error and
 *       \ref flashcalw_is_programming_error is updated.
 */
void flashcalw_issue_command(uint32_t command, int page_number)
{
     bc4:	b538      	push	{r3, r4, r5, lr}
     bc6:	4605      	mov	r5, r0
     bc8:	460c      	mov	r4, r1
	uint32_t tempo;

	flashcalw_wait_until_ready();
     bca:	4b10      	ldr	r3, [pc, #64]	; (c0c <flashcalw_issue_command+0x48>)
     bcc:	681b      	ldr	r3, [r3, #0]
     bce:	4798      	blx	r3
	tempo = HFLASHC->FLASHCALW_FCMD;
     bd0:	4b0f      	ldr	r3, [pc, #60]	; (c10 <flashcalw_issue_command+0x4c>)
     bd2:	685b      	ldr	r3, [r3, #4]
	/* Clear the command bitfield. */
	tempo &= ~FLASHCALW_FCMD_CMD_Msk;
	if (page_number >= 0) {
     bd4:	2c00      	cmp	r4, #0
     bd6:	db12      	blt.n	bfe <flashcalw_issue_command+0x3a>
		tempo = (FLASHCALW_FCMD_KEY_KEY
				| FLASHCALW_FCMD_PAGEN(page_number) | command);
     bd8:	0224      	lsls	r4, r4, #8
     bda:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
     bde:	f024 04ff 	bic.w	r4, r4, #255	; 0xff
		tempo = (FLASHCALW_FCMD_KEY_KEY
     be2:	f045 4525 	orr.w	r5, r5, #2768240640	; 0xa5000000
     be6:	432c      	orrs	r4, r5
	} else {
		tempo |= (FLASHCALW_FCMD_KEY_KEY | command);
	}

	HFLASHC->FLASHCALW_FCMD = tempo;
     be8:	4b09      	ldr	r3, [pc, #36]	; (c10 <flashcalw_issue_command+0x4c>)
     bea:	605c      	str	r4, [r3, #4]
	return HFLASHC->FLASHCALW_FSR &
     bec:	689b      	ldr	r3, [r3, #8]
     bee:	f003 030c 	and.w	r3, r3, #12
	flashcalw_error_status = flashcalw_get_error_status();
     bf2:	4a08      	ldr	r2, [pc, #32]	; (c14 <flashcalw_issue_command+0x50>)
     bf4:	6013      	str	r3, [r2, #0]
	flashcalw_wait_until_ready();
     bf6:	4b05      	ldr	r3, [pc, #20]	; (c0c <flashcalw_issue_command+0x48>)
     bf8:	681b      	ldr	r3, [r3, #0]
     bfa:	4798      	blx	r3
     bfc:	bd38      	pop	{r3, r4, r5, pc}
	tempo &= ~FLASHCALW_FCMD_CMD_Msk;
     bfe:	f023 043f 	bic.w	r4, r3, #63	; 0x3f
     c02:	f044 4425 	orr.w	r4, r4, #2768240640	; 0xa5000000
		tempo |= (FLASHCALW_FCMD_KEY_KEY | command);
     c06:	432c      	orrs	r4, r5
     c08:	e7ee      	b.n	be8 <flashcalw_issue_command+0x24>
     c0a:	bf00      	nop
     c0c:	2000002c 	.word	0x2000002c
     c10:	400a0000 	.word	0x400a0000
     c14:	20000484 	.word	0x20000484

00000c18 <flashcalw_set_flash_waitstate_and_readmode>:
{
     c18:	b508      	push	{r3, lr}
	if (ps_value == 0) {
     c1a:	2900      	cmp	r1, #0
     c1c:	d12d      	bne.n	c7a <flashcalw_set_flash_waitstate_and_readmode+0x62>
		if (cpu_f_hz > FLASH_FREQ_PS0_FWS_0_MAX_FREQ) {
     c1e:	4b1d      	ldr	r3, [pc, #116]	; (c94 <flashcalw_set_flash_waitstate_and_readmode+0x7c>)
     c20:	4298      	cmp	r0, r3
     c22:	d914      	bls.n	c4e <flashcalw_set_flash_waitstate_and_readmode+0x36>
			if (cpu_f_hz <= FLASH_FREQ_PS0_FWS_1_MAX_FREQ) {
     c24:	4b1c      	ldr	r3, [pc, #112]	; (c98 <flashcalw_set_flash_waitstate_and_readmode+0x80>)
     c26:	4298      	cmp	r0, r3
     c28:	d808      	bhi.n	c3c <flashcalw_set_flash_waitstate_and_readmode+0x24>
				flashcalw_set_wait_state(1);
     c2a:	2001      	movs	r0, #1
     c2c:	4b1b      	ldr	r3, [pc, #108]	; (c9c <flashcalw_set_flash_waitstate_and_readmode+0x84>)
     c2e:	4798      	blx	r3
				flashcalw_issue_command(
     c30:	f04f 31ff 	mov.w	r1, #4294967295
     c34:	2011      	movs	r0, #17
     c36:	4b1a      	ldr	r3, [pc, #104]	; (ca0 <flashcalw_set_flash_waitstate_and_readmode+0x88>)
     c38:	4798      	blx	r3
     c3a:	bd08      	pop	{r3, pc}
				flashcalw_set_wait_state(1);
     c3c:	2001      	movs	r0, #1
     c3e:	4b17      	ldr	r3, [pc, #92]	; (c9c <flashcalw_set_flash_waitstate_and_readmode+0x84>)
     c40:	4798      	blx	r3
				flashcalw_issue_command(FLASHCALW_FCMD_CMD_HSEN,
     c42:	f04f 31ff 	mov.w	r1, #4294967295
     c46:	2010      	movs	r0, #16
     c48:	4b15      	ldr	r3, [pc, #84]	; (ca0 <flashcalw_set_flash_waitstate_and_readmode+0x88>)
     c4a:	4798      	blx	r3
     c4c:	bd08      	pop	{r3, pc}
			if((is_fwu_enabled == true) &&
     c4e:	b112      	cbz	r2, c56 <flashcalw_set_flash_waitstate_and_readmode+0x3e>
     c50:	4b14      	ldr	r3, [pc, #80]	; (ca4 <flashcalw_set_flash_waitstate_and_readmode+0x8c>)
     c52:	4298      	cmp	r0, r3
     c54:	d908      	bls.n	c68 <flashcalw_set_flash_waitstate_and_readmode+0x50>
				flashcalw_set_wait_state(0);
     c56:	2000      	movs	r0, #0
     c58:	4b10      	ldr	r3, [pc, #64]	; (c9c <flashcalw_set_flash_waitstate_and_readmode+0x84>)
     c5a:	4798      	blx	r3
				flashcalw_issue_command(
     c5c:	f04f 31ff 	mov.w	r1, #4294967295
     c60:	2011      	movs	r0, #17
     c62:	4b0f      	ldr	r3, [pc, #60]	; (ca0 <flashcalw_set_flash_waitstate_and_readmode+0x88>)
     c64:	4798      	blx	r3
     c66:	bd08      	pop	{r3, pc}
				flashcalw_set_wait_state(1);
     c68:	2001      	movs	r0, #1
     c6a:	4b0c      	ldr	r3, [pc, #48]	; (c9c <flashcalw_set_flash_waitstate_and_readmode+0x84>)
     c6c:	4798      	blx	r3
				flashcalw_issue_command(
     c6e:	f04f 31ff 	mov.w	r1, #4294967295
     c72:	2011      	movs	r0, #17
     c74:	4b0a      	ldr	r3, [pc, #40]	; (ca0 <flashcalw_set_flash_waitstate_and_readmode+0x88>)
     c76:	4798      	blx	r3
     c78:	bd08      	pop	{r3, pc}
		if (cpu_f_hz > FLASH_FREQ_PS1_FWS_0_MAX_FREQ) { /* > 8MHz */
     c7a:	4b0b      	ldr	r3, [pc, #44]	; (ca8 <flashcalw_set_flash_waitstate_and_readmode+0x90>)
     c7c:	4298      	cmp	r0, r3
			flashcalw_set_wait_state(1);
     c7e:	bf8c      	ite	hi
     c80:	2001      	movhi	r0, #1
			flashcalw_set_wait_state(0);
     c82:	2000      	movls	r0, #0
     c84:	4b05      	ldr	r3, [pc, #20]	; (c9c <flashcalw_set_flash_waitstate_and_readmode+0x84>)
     c86:	4798      	blx	r3
		flashcalw_issue_command(FLASHCALW_FCMD_CMD_HSDIS, -1);
     c88:	f04f 31ff 	mov.w	r1, #4294967295
     c8c:	2011      	movs	r0, #17
     c8e:	4b04      	ldr	r3, [pc, #16]	; (ca0 <flashcalw_set_flash_waitstate_and_readmode+0x88>)
     c90:	4798      	blx	r3
     c92:	bd08      	pop	{r3, pc}
     c94:	0112a880 	.word	0x0112a880
     c98:	02255100 	.word	0x02255100
     c9c:	00000b89 	.word	0x00000b89
     ca0:	00000bc5 	.word	0x00000bc5
     ca4:	00b71b00 	.word	0x00b71b00
     ca8:	007a1200 	.word	0x007a1200

00000cac <gpio_common_handler>:

/**
 * Common GPIO handler.
 */
static void gpio_common_handler(uint32_t port_id, uint32_t port_mask)
{
     cac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
     cb0:	b083      	sub	sp, #12
     cb2:	9101      	str	r1, [sp, #4]
	GpioPort *gpio_port = &(GPIO->GPIO_PORT[port_id]);
     cb4:	0247      	lsls	r7, r0, #9
     cb6:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
     cba:	f507 2761 	add.w	r7, r7, #921600	; 0xe1000
	uint32_t i;
	uint32_t int_flags;
	ioport_pin_t pin;

	int_flags = gpio_port->GPIO_IFR;
     cbe:	f8d7 a0d0 	ldr.w	sl, [r7, #208]	; 0xd0

	for (i = 0; i < gpio_nb_sources; i++) {
     cc2:	4b15      	ldr	r3, [pc, #84]	; (d18 <gpio_common_handler+0x6c>)
     cc4:	681b      	ldr	r3, [r3, #0]
     cc6:	b1fb      	cbz	r3, d08 <gpio_common_handler+0x5c>
     cc8:	4606      	mov	r6, r0
     cca:	4d14      	ldr	r5, [pc, #80]	; (d1c <gpio_common_handler+0x70>)
     ccc:	2400      	movs	r4, #0
		pin = gpio_int_sources[i].pin;
     cce:	46a9      	mov	r9, r5
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
     cd0:	f04f 0b01 	mov.w	fp, #1
	for (i = 0; i < gpio_nb_sources; i++) {
     cd4:	f8df 8040 	ldr.w	r8, [pc, #64]	; d18 <gpio_common_handler+0x6c>
     cd8:	e005      	b.n	ce6 <gpio_common_handler+0x3a>
     cda:	3401      	adds	r4, #1
     cdc:	3508      	adds	r5, #8
     cde:	f8d8 3000 	ldr.w	r3, [r8]
     ce2:	42a3      	cmp	r3, r4
     ce4:	d910      	bls.n	d08 <gpio_common_handler+0x5c>
		pin = gpio_int_sources[i].pin;
     ce6:	f859 3034 	ldr.w	r3, [r9, r4, lsl #3]
		if ((ioport_pin_to_port_id(pin) == port_id) &&
     cea:	ebb6 1f53 	cmp.w	r6, r3, lsr #5
     cee:	d1f4      	bne.n	cda <gpio_common_handler+0x2e>
     cf0:	f003 031f 	and.w	r3, r3, #31
     cf4:	fa0b f303 	lsl.w	r3, fp, r3
     cf8:	ea13 0f0a 	tst.w	r3, sl
     cfc:	d0ed      	beq.n	cda <gpio_common_handler+0x2e>
				(ioport_pin_to_mask(pin) & int_flags)) {
			if (gpio_int_sources[i].callback != NULL) {
     cfe:	686b      	ldr	r3, [r5, #4]
     d00:	2b00      	cmp	r3, #0
     d02:	d0ea      	beq.n	cda <gpio_common_handler+0x2e>
				gpio_int_sources[i].callback();
     d04:	4798      	blx	r3
     d06:	e7e8      	b.n	cda <gpio_common_handler+0x2e>
				Assert(false); /* Catch unexpected interrupt */
			}
		}
	}

	gpio_port->GPIO_IFRC = (int_flags & port_mask);
     d08:	9b01      	ldr	r3, [sp, #4]
     d0a:	ea0a 0303 	and.w	r3, sl, r3
     d0e:	f8c7 30d8 	str.w	r3, [r7, #216]	; 0xd8
}
     d12:	b003      	add	sp, #12
     d14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
     d18:	200004b8 	.word	0x200004b8
     d1c:	20000488 	.word	0x20000488

00000d20 <GPIO_0_Handler>:

/**
 * GPIO handler 0 (PA 0..7)
 */
void GPIO_0_Handler(void)
{
     d20:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOA, GPIO_INT_GROUP_MASK);
     d22:	21ff      	movs	r1, #255	; 0xff
     d24:	2000      	movs	r0, #0
     d26:	4b01      	ldr	r3, [pc, #4]	; (d2c <GPIO_0_Handler+0xc>)
     d28:	4798      	blx	r3
     d2a:	bd08      	pop	{r3, pc}
     d2c:	00000cad 	.word	0x00000cad

00000d30 <GPIO_1_Handler>:

/**
 * GPIO handler 1 (PA 8..15)
 */
void GPIO_1_Handler(void)
{
     d30:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOA, (GPIO_INT_GROUP_MASK << 8));
     d32:	f44f 417f 	mov.w	r1, #65280	; 0xff00
     d36:	2000      	movs	r0, #0
     d38:	4b01      	ldr	r3, [pc, #4]	; (d40 <GPIO_1_Handler+0x10>)
     d3a:	4798      	blx	r3
     d3c:	bd08      	pop	{r3, pc}
     d3e:	bf00      	nop
     d40:	00000cad 	.word	0x00000cad

00000d44 <GPIO_2_Handler>:

/**
 * GPIO handler 2 (PA 16..23)
 */
void GPIO_2_Handler(void)
{
     d44:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOA, (GPIO_INT_GROUP_MASK << 16));
     d46:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
     d4a:	2000      	movs	r0, #0
     d4c:	4b01      	ldr	r3, [pc, #4]	; (d54 <GPIO_2_Handler+0x10>)
     d4e:	4798      	blx	r3
     d50:	bd08      	pop	{r3, pc}
     d52:	bf00      	nop
     d54:	00000cad 	.word	0x00000cad

00000d58 <GPIO_3_Handler>:

/**
 * GPIO handler 3 (PA 24..31)
 */
void GPIO_3_Handler(void)
{
     d58:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOA, (GPIO_INT_GROUP_MASK << 24));
     d5a:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
     d5e:	2000      	movs	r0, #0
     d60:	4b01      	ldr	r3, [pc, #4]	; (d68 <GPIO_3_Handler+0x10>)
     d62:	4798      	blx	r3
     d64:	bd08      	pop	{r3, pc}
     d66:	bf00      	nop
     d68:	00000cad 	.word	0x00000cad

00000d6c <GPIO_4_Handler>:

/**
 * GPIO handler 4 (PB 0..7)
 */
void GPIO_4_Handler(void)
{
     d6c:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOB, GPIO_INT_GROUP_MASK);
     d6e:	21ff      	movs	r1, #255	; 0xff
     d70:	2001      	movs	r0, #1
     d72:	4b01      	ldr	r3, [pc, #4]	; (d78 <GPIO_4_Handler+0xc>)
     d74:	4798      	blx	r3
     d76:	bd08      	pop	{r3, pc}
     d78:	00000cad 	.word	0x00000cad

00000d7c <GPIO_5_Handler>:

/**
 * GPIO handler 5 (PB 8..15)
 */
void GPIO_5_Handler(void)
{
     d7c:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOB, (GPIO_INT_GROUP_MASK << 8));
     d7e:	f44f 417f 	mov.w	r1, #65280	; 0xff00
     d82:	2001      	movs	r0, #1
     d84:	4b01      	ldr	r3, [pc, #4]	; (d8c <GPIO_5_Handler+0x10>)
     d86:	4798      	blx	r3
     d88:	bd08      	pop	{r3, pc}
     d8a:	bf00      	nop
     d8c:	00000cad 	.word	0x00000cad

00000d90 <GPIO_6_Handler>:

/**
 * GPIO handler 6 (PB 16..23)
 */
void GPIO_6_Handler(void)
{
     d90:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOB, (GPIO_INT_GROUP_MASK << 16));
     d92:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
     d96:	2001      	movs	r0, #1
     d98:	4b01      	ldr	r3, [pc, #4]	; (da0 <GPIO_6_Handler+0x10>)
     d9a:	4798      	blx	r3
     d9c:	bd08      	pop	{r3, pc}
     d9e:	bf00      	nop
     da0:	00000cad 	.word	0x00000cad

00000da4 <GPIO_7_Handler>:

/**
 * GPIO handler 7 (PB 24..31)
 */
void GPIO_7_Handler(void)
{
     da4:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOB, (GPIO_INT_GROUP_MASK << 24));
     da6:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
     daa:	2001      	movs	r0, #1
     dac:	4b01      	ldr	r3, [pc, #4]	; (db4 <GPIO_7_Handler+0x10>)
     dae:	4798      	blx	r3
     db0:	bd08      	pop	{r3, pc}
     db2:	bf00      	nop
     db4:	00000cad 	.word	0x00000cad

00000db8 <GPIO_8_Handler>:

/**
 * GPIO handler 8 (PC 0..7)
 */
void GPIO_8_Handler(void)
{
     db8:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOC, GPIO_INT_GROUP_MASK);
     dba:	21ff      	movs	r1, #255	; 0xff
     dbc:	2002      	movs	r0, #2
     dbe:	4b01      	ldr	r3, [pc, #4]	; (dc4 <GPIO_8_Handler+0xc>)
     dc0:	4798      	blx	r3
     dc2:	bd08      	pop	{r3, pc}
     dc4:	00000cad 	.word	0x00000cad

00000dc8 <GPIO_9_Handler>:

/**
 * GPIO handler 9 (PC 8..15)
 */
void GPIO_9_Handler(void)
{
     dc8:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOC, (GPIO_INT_GROUP_MASK << 8));
     dca:	f44f 417f 	mov.w	r1, #65280	; 0xff00
     dce:	2002      	movs	r0, #2
     dd0:	4b01      	ldr	r3, [pc, #4]	; (dd8 <GPIO_9_Handler+0x10>)
     dd2:	4798      	blx	r3
     dd4:	bd08      	pop	{r3, pc}
     dd6:	bf00      	nop
     dd8:	00000cad 	.word	0x00000cad

00000ddc <GPIO_10_Handler>:

/**
 * GPIO handler 10 (PC 16..23)
 */
void GPIO_10_Handler(void)
{
     ddc:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOC, (GPIO_INT_GROUP_MASK << 16));
     dde:	f44f 017f 	mov.w	r1, #16711680	; 0xff0000
     de2:	2002      	movs	r0, #2
     de4:	4b01      	ldr	r3, [pc, #4]	; (dec <GPIO_10_Handler+0x10>)
     de6:	4798      	blx	r3
     de8:	bd08      	pop	{r3, pc}
     dea:	bf00      	nop
     dec:	00000cad 	.word	0x00000cad

00000df0 <GPIO_11_Handler>:

/**
 * GPIO handler 11 (PC 24..31)
 */
void GPIO_11_Handler(void)
{
     df0:	b508      	push	{r3, lr}
	gpio_common_handler(IOPORT_GPIOC, (GPIO_INT_GROUP_MASK << 24));
     df2:	f04f 417f 	mov.w	r1, #4278190080	; 0xff000000
     df6:	2002      	movs	r0, #2
     df8:	4b01      	ldr	r3, [pc, #4]	; (e00 <GPIO_11_Handler+0x10>)
     dfa:	4798      	blx	r3
     dfc:	bd08      	pop	{r3, pc}
     dfe:	bf00      	nop
     e00:	00000cad 	.word	0x00000cad

00000e04 <board_init>:
#include <asf.h>
#include <board.h>
#include <conf_board.h>

void board_init(void)
{	
     e04:	4770      	bx	lr

00000e06 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
     e06:	e7fe      	b.n	e06 <Dummy_Handler>

00000e08 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
     e08:	b508      	push	{r3, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
     e0a:	4b17      	ldr	r3, [pc, #92]	; (e68 <Reset_Handler+0x60>)
     e0c:	4a17      	ldr	r2, [pc, #92]	; (e6c <Reset_Handler+0x64>)
     e0e:	429a      	cmp	r2, r3
     e10:	d010      	beq.n	e34 <Reset_Handler+0x2c>
		for (; pDest < &_erelocate;) {
     e12:	4b17      	ldr	r3, [pc, #92]	; (e70 <Reset_Handler+0x68>)
     e14:	4a14      	ldr	r2, [pc, #80]	; (e68 <Reset_Handler+0x60>)
     e16:	429a      	cmp	r2, r3
     e18:	d20c      	bcs.n	e34 <Reset_Handler+0x2c>
     e1a:	3b01      	subs	r3, #1
     e1c:	1a9b      	subs	r3, r3, r2
     e1e:	f023 0303 	bic.w	r3, r3, #3
     e22:	3304      	adds	r3, #4
     e24:	4413      	add	r3, r2
     e26:	4911      	ldr	r1, [pc, #68]	; (e6c <Reset_Handler+0x64>)
			*pDest++ = *pSrc++;
     e28:	f851 0b04 	ldr.w	r0, [r1], #4
     e2c:	f842 0b04 	str.w	r0, [r2], #4
		for (; pDest < &_erelocate;) {
     e30:	429a      	cmp	r2, r3
     e32:	d1f9      	bne.n	e28 <Reset_Handler+0x20>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
     e34:	4b0f      	ldr	r3, [pc, #60]	; (e74 <Reset_Handler+0x6c>)
     e36:	4a10      	ldr	r2, [pc, #64]	; (e78 <Reset_Handler+0x70>)
     e38:	429a      	cmp	r2, r3
     e3a:	d20a      	bcs.n	e52 <Reset_Handler+0x4a>
     e3c:	3b01      	subs	r3, #1
     e3e:	1a9b      	subs	r3, r3, r2
     e40:	f023 0303 	bic.w	r3, r3, #3
     e44:	3304      	adds	r3, #4
     e46:	4413      	add	r3, r2
		*pDest++ = 0;
     e48:	2100      	movs	r1, #0
     e4a:	f842 1b04 	str.w	r1, [r2], #4
	for (pDest = &_szero; pDest < &_ezero;) {
     e4e:	4293      	cmp	r3, r2
     e50:	d1fb      	bne.n	e4a <Reset_Handler+0x42>
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) &_sfixed;
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
     e52:	4a0a      	ldr	r2, [pc, #40]	; (e7c <Reset_Handler+0x74>)
     e54:	4b0a      	ldr	r3, [pc, #40]	; (e80 <Reset_Handler+0x78>)
     e56:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
     e5a:	6093      	str	r3, [r2, #8]

	/* Initialize the C library */
	__libc_init_array();
     e5c:	4b09      	ldr	r3, [pc, #36]	; (e84 <Reset_Handler+0x7c>)
     e5e:	4798      	blx	r3

	/* Branch to main function */
	main();
     e60:	4b09      	ldr	r3, [pc, #36]	; (e88 <Reset_Handler+0x80>)
     e62:	4798      	blx	r3
     e64:	e7fe      	b.n	e64 <Reset_Handler+0x5c>
     e66:	bf00      	nop
     e68:	20000000 	.word	0x20000000
     e6c:	000011b8 	.word	0x000011b8
     e70:	20000464 	.word	0x20000464
     e74:	200004e0 	.word	0x200004e0
     e78:	20000464 	.word	0x20000464
     e7c:	e000ed00 	.word	0xe000ed00
     e80:	00000000 	.word	0x00000000
     e84:	0000100d 	.word	0x0000100d
     e88:	00000ec9 	.word	0x00000ec9

00000e8c <USART1_Handler>:
} while (0)


/* usart receive interrupt handler */
void CONF_UART_ISR_HANDLER(void)
{
     e8c:	b510      	push	{r4, lr}
     e8e:	b082      	sub	sp, #8
	uint32_t dw_status = usart_get_status(CONF_UART);
     e90:	4808      	ldr	r0, [pc, #32]	; (eb4 <USART1_Handler+0x28>)
     e92:	4b09      	ldr	r3, [pc, #36]	; (eb8 <USART1_Handler+0x2c>)
     e94:	4798      	blx	r3
	if (dw_status & US_CSR_RXRDY) {
     e96:	f010 0f01 	tst.w	r0, #1
     e9a:	d101      	bne.n	ea0 <USART1_Handler+0x14>
		uint32_t received_byte;
		usart_read(CONF_UART, &received_byte);
		usart_write_line(CONF_UART, "HELLO");
	}
}
     e9c:	b002      	add	sp, #8
     e9e:	bd10      	pop	{r4, pc}
		usart_read(CONF_UART, &received_byte);
     ea0:	4c04      	ldr	r4, [pc, #16]	; (eb4 <USART1_Handler+0x28>)
     ea2:	a901      	add	r1, sp, #4
     ea4:	4620      	mov	r0, r4
     ea6:	4b05      	ldr	r3, [pc, #20]	; (ebc <USART1_Handler+0x30>)
     ea8:	4798      	blx	r3
		usart_write_line(CONF_UART, "HELLO");
     eaa:	4905      	ldr	r1, [pc, #20]	; (ec0 <USART1_Handler+0x34>)
     eac:	4620      	mov	r0, r4
     eae:	4b05      	ldr	r3, [pc, #20]	; (ec4 <USART1_Handler+0x38>)
     eb0:	4798      	blx	r3
}
     eb2:	e7f3      	b.n	e9c <USART1_Handler+0x10>
     eb4:	40028000 	.word	0x40028000
     eb8:	000002d9 	.word	0x000002d9
     ebc:	00000311 	.word	0x00000311
     ec0:	0000117c 	.word	0x0000117c
     ec4:	000002f1 	.word	0x000002f1

00000ec8 <main>:



int main (void)
{
     ec8:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
     ecc:	b087      	sub	sp, #28
	
	/* Insert system clock initialization code here (sysclk_init()). */
	sysclk_init(); 
     ece:	4b40      	ldr	r3, [pc, #256]	; (fd0 <main+0x108>)
     ed0:	4798      	blx	r3
	board_init();
     ed2:	4b40      	ldr	r3, [pc, #256]	; (fd4 <main+0x10c>)
     ed4:	4798      	blx	r3
}

__always_inline static void arch_ioport_init(void)
{
	sysclk_enable_peripheral_clock(GPIO);
     ed6:	4840      	ldr	r0, [pc, #256]	; (fd8 <main+0x110>)
     ed8:	4e40      	ldr	r6, [pc, #256]	; (fdc <main+0x114>)
     eda:	47b0      	blx	r6
	volatile GpioPort *base = arch_ioport_port_to_base(port);

	if (mode & IOPORT_MODE_PULLUP) {
		base->GPIO_PUERS = mask;
	} else {
		base->GPIO_PUERC = mask;
     edc:	4b40      	ldr	r3, [pc, #256]	; (fe0 <main+0x118>)
     ede:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
     ee2:	679a      	str	r2, [r3, #120]	; 0x78

#ifdef IOPORT_MODE_PULLDOWN
	if (mode & IOPORT_MODE_PULLDOWN) {
		base->GPIO_PDERS = mask;
	} else {
		base->GPIO_PDERC = mask;
     ee4:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
#endif

	if (mode & IOPORT_MODE_GLITCH_FILTER) {
		base->GPIO_GFERS = mask;
	} else {
		base->GPIO_GFERC = mask;
     ee8:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8

#ifdef IOPORT_MODE_DRIVE_STRENGTH
	if (mode & IOPORT_MODE_DRIVE_STRENGTH) {
		base->GPIO_ODCR0S = mask;
	} else {
		base->GPIO_ODCR0C = mask;
     eec:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
#endif

	if (mode & IOPORT_MODE_MUX_BIT0) {
		base->GPIO_PMR0S = mask;
	} else {
		base->GPIO_PMR0C = mask;
     ef0:	619a      	str	r2, [r3, #24]
	}

	if (mode & IOPORT_MODE_MUX_BIT1) {
		base->GPIO_PMR1S = mask;
	} else {
		base->GPIO_PMR1C = mask;
     ef2:	629a      	str	r2, [r3, #40]	; 0x28

#ifdef IOPORT_MODE_MUX_BIT2
	if (mode & IOPORT_MODE_MUX_BIT2) {
		base->GPIO_PMR2S = mask;
	} else {
		base->GPIO_PMR2C = mask;
     ef4:	639a      	str	r2, [r3, #56]	; 0x38
	arch_ioport_port_to_base(port)->GPIO_GPERC = mask;
     ef6:	609a      	str	r2, [r3, #8]
		base->GPIO_PUERC = mask;
     ef8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
     efc:	679a      	str	r2, [r3, #120]	; 0x78
		base->GPIO_PDERC = mask;
     efe:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		base->GPIO_GFERC = mask;
     f02:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
		base->GPIO_ODCR0C = mask;
     f06:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
		base->GPIO_PMR0C = mask;
     f0a:	619a      	str	r2, [r3, #24]
		base->GPIO_PMR1C = mask;
     f0c:	629a      	str	r2, [r3, #40]	; 0x28
		base->GPIO_PMR2C = mask;
     f0e:	639a      	str	r2, [r3, #56]	; 0x38
	arch_ioport_port_to_base(port)->GPIO_GPERC = mask;
     f10:	609a      	str	r2, [r3, #8]
		base->GPIO_PUERC = mask;
     f12:	f5a3 7300 	sub.w	r3, r3, #512	; 0x200
     f16:	2401      	movs	r4, #1
     f18:	679c      	str	r4, [r3, #120]	; 0x78
		base->GPIO_PDERC = mask;
     f1a:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
		base->GPIO_GFERC = mask;
     f1e:	f8c3 40c8 	str.w	r4, [r3, #200]	; 0xc8
		base->GPIO_ODCR0C = mask;
     f22:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
		base->GPIO_PMR0S = mask;
     f26:	615c      	str	r4, [r3, #20]
		base->GPIO_PMR1C = mask;
     f28:	629c      	str	r4, [r3, #40]	; 0x28
		base->GPIO_PMR2C = mask;
     f2a:	639c      	str	r4, [r3, #56]	; 0x38
	arch_ioport_port_to_base(port)->GPIO_GPERC = mask;
     f2c:	609c      	str	r4, [r3, #8]
		base->GPIO_PUERC = mask;
     f2e:	2202      	movs	r2, #2
     f30:	679a      	str	r2, [r3, #120]	; 0x78
		base->GPIO_PDERC = mask;
     f32:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
		base->GPIO_GFERC = mask;
     f36:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
		base->GPIO_ODCR0C = mask;
     f3a:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
		base->GPIO_PMR0S = mask;
     f3e:	615a      	str	r2, [r3, #20]
		base->GPIO_PMR1C = mask;
     f40:	629a      	str	r2, [r3, #40]	; 0x28
		base->GPIO_PMR2C = mask;
     f42:	639a      	str	r2, [r3, #56]	; 0x38
	arch_ioport_port_to_base(port)->GPIO_GPERC = mask;
     f44:	609a      	str	r2, [r3, #8]
	uart_settings.ul_baudrate = opt->baudrate;
	uart_settings.ul_mode = opt->paritytype;
#endif

	sam_usart_opt_t usart_settings;
	usart_settings.baudrate = opt->baudrate;
     f46:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
     f4a:	9300      	str	r3, [sp, #0]
	usart_settings.char_length = opt->charlength;
     f4c:	f04f 0bc0 	mov.w	fp, #192	; 0xc0
     f50:	f8cd b004 	str.w	fp, [sp, #4]
	usart_settings.parity_type = opt->paritytype;
     f54:	f44f 6a00 	mov.w	sl, #2048	; 0x800
     f58:	f8cd a008 	str.w	sl, [sp, #8]
	usart_settings.stop_bits= opt->stopbits;
     f5c:	2500      	movs	r5, #0
     f5e:	9503      	str	r5, [sp, #12]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
     f60:	9504      	str	r5, [sp, #16]
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
				sysclk_get_peripheral_hz());
#endif
#if (SAM4L)
		sysclk_enable_peripheral_clock(p_usart);
     f62:	4820      	ldr	r0, [pc, #128]	; (fe4 <main+0x11c>)
     f64:	47b0      	blx	r6
		/* Configure USART */
		usart_init_rs232(p_usart, &usart_settings,
     f66:	481f      	ldr	r0, [pc, #124]	; (fe4 <main+0x11c>)
     f68:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1004 <__stack_size__+0x4>
     f6c:	47c8      	blx	r9
     f6e:	4602      	mov	r2, r0
     f70:	4669      	mov	r1, sp
     f72:	481c      	ldr	r0, [pc, #112]	; (fe4 <main+0x11c>)
     f74:	4b1c      	ldr	r3, [pc, #112]	; (fe8 <main+0x120>)
     f76:	4798      	blx	r3
				sysclk_get_peripheral_bus_hz(p_usart));
#endif
		/* Enable the receiver and transmitter. */
		usart_enable_tx(p_usart);
     f78:	481a      	ldr	r0, [pc, #104]	; (fe4 <main+0x11c>)
     f7a:	4f1c      	ldr	r7, [pc, #112]	; (fec <main+0x124>)
     f7c:	47b8      	blx	r7
		usart_enable_rx(p_usart);
     f7e:	4819      	ldr	r0, [pc, #100]	; (fe4 <main+0x11c>)
     f80:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1008 <__stack_size__+0x8>
     f84:	47c0      	blx	r8
	usart_settings.baudrate = opt->baudrate;
     f86:	f44f 5316 	mov.w	r3, #9600	; 0x2580
     f8a:	9300      	str	r3, [sp, #0]
	usart_settings.char_length = opt->charlength;
     f8c:	f8cd b004 	str.w	fp, [sp, #4]
	usart_settings.parity_type = opt->paritytype;
     f90:	f8cd a008 	str.w	sl, [sp, #8]
	usart_settings.stop_bits= opt->stopbits;
     f94:	9503      	str	r5, [sp, #12]
	usart_settings.channel_mode= US_MR_CHMODE_NORMAL;
     f96:	9504      	str	r5, [sp, #16]
		sysclk_enable_peripheral_clock(p_usart);
     f98:	4d15      	ldr	r5, [pc, #84]	; (ff0 <main+0x128>)
     f9a:	4628      	mov	r0, r5
     f9c:	47b0      	blx	r6
		usart_init_rs232(p_usart, &usart_settings,
     f9e:	4628      	mov	r0, r5
     fa0:	47c8      	blx	r9
     fa2:	4602      	mov	r2, r0
     fa4:	4669      	mov	r1, sp
     fa6:	4628      	mov	r0, r5
     fa8:	4b0f      	ldr	r3, [pc, #60]	; (fe8 <main+0x120>)
     faa:	4798      	blx	r3
		usart_enable_tx(p_usart);
     fac:	4628      	mov	r0, r5
     fae:	47b8      	blx	r7
		usart_enable_rx(p_usart);
     fb0:	4628      	mov	r0, r5
     fb2:	47c0      	blx	r8
	usart_serial_init(CONF_UART , &conf_uart_serial_options) ;
	usart_serial_init(USART_SERIAL , &uart_serial_options) ; 
	
	
	/* setting the type of usart interrupt: in this case receive ready*/
	 usart_enable_interrupt(CONF_UART,US_IER_RXRDY);
     fb4:	4621      	mov	r1, r4
     fb6:	480b      	ldr	r0, [pc, #44]	; (fe4 <main+0x11c>)
     fb8:	4b0e      	ldr	r3, [pc, #56]	; (ff4 <main+0x12c>)
     fba:	4798      	blx	r3
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
     fbc:	2204      	movs	r2, #4
     fbe:	4b0e      	ldr	r3, [pc, #56]	; (ff8 <main+0x130>)
     fc0:	609a      	str	r2, [r3, #8]
		
		/* put this part of USART receive into an interrupt service routine */		
		//usart_write_line(CONF_UART , "hello"); */ 
		
		
		usart_write_line(USART_SERIAL , "to arduino"); 		
     fc2:	4e0e      	ldr	r6, [pc, #56]	; (ffc <main+0x134>)
     fc4:	4c0e      	ldr	r4, [pc, #56]	; (1000 <__stack_size__>)
     fc6:	4631      	mov	r1, r6
     fc8:	4628      	mov	r0, r5
     fca:	47a0      	blx	r4
     fcc:	e7fb      	b.n	fc6 <main+0xfe>
     fce:	bf00      	nop
     fd0:	00000a65 	.word	0x00000a65
     fd4:	00000e05 	.word	0x00000e05
     fd8:	400e1000 	.word	0x400e1000
     fdc:	00000631 	.word	0x00000631
     fe0:	400e1400 	.word	0x400e1400
     fe4:	40028000 	.word	0x40028000
     fe8:	00000275 	.word	0x00000275
     fec:	000002c9 	.word	0x000002c9
     ff0:	40024000 	.word	0x40024000
     ff4:	000002d5 	.word	0x000002d5
     ff8:	e000e100 	.word	0xe000e100
     ffc:	00001184 	.word	0x00001184
    1000:	000002f1 	.word	0x000002f1
    1004:	00000481 	.word	0x00000481
    1008:	000002cf 	.word	0x000002cf

0000100c <__libc_init_array>:
    100c:	b570      	push	{r4, r5, r6, lr}
    100e:	4e0f      	ldr	r6, [pc, #60]	; (104c <__libc_init_array+0x40>)
    1010:	4d0f      	ldr	r5, [pc, #60]	; (1050 <__libc_init_array+0x44>)
    1012:	1b76      	subs	r6, r6, r5
    1014:	10b6      	asrs	r6, r6, #2
    1016:	bf18      	it	ne
    1018:	2400      	movne	r4, #0
    101a:	d005      	beq.n	1028 <__libc_init_array+0x1c>
    101c:	3401      	adds	r4, #1
    101e:	f855 3b04 	ldr.w	r3, [r5], #4
    1022:	4798      	blx	r3
    1024:	42a6      	cmp	r6, r4
    1026:	d1f9      	bne.n	101c <__libc_init_array+0x10>
    1028:	4e0a      	ldr	r6, [pc, #40]	; (1054 <__libc_init_array+0x48>)
    102a:	4d0b      	ldr	r5, [pc, #44]	; (1058 <__libc_init_array+0x4c>)
    102c:	1b76      	subs	r6, r6, r5
    102e:	f000 f8b1 	bl	1194 <_init>
    1032:	10b6      	asrs	r6, r6, #2
    1034:	bf18      	it	ne
    1036:	2400      	movne	r4, #0
    1038:	d006      	beq.n	1048 <__libc_init_array+0x3c>
    103a:	3401      	adds	r4, #1
    103c:	f855 3b04 	ldr.w	r3, [r5], #4
    1040:	4798      	blx	r3
    1042:	42a6      	cmp	r6, r4
    1044:	d1f9      	bne.n	103a <__libc_init_array+0x2e>
    1046:	bd70      	pop	{r4, r5, r6, pc}
    1048:	bd70      	pop	{r4, r5, r6, pc}
    104a:	bf00      	nop
    104c:	000011a0 	.word	0x000011a0
    1050:	000011a0 	.word	0x000011a0
    1054:	000011a8 	.word	0x000011a8
    1058:	000011a0 	.word	0x000011a0

0000105c <register_fini>:
    105c:	4b02      	ldr	r3, [pc, #8]	; (1068 <register_fini+0xc>)
    105e:	b113      	cbz	r3, 1066 <register_fini+0xa>
    1060:	4802      	ldr	r0, [pc, #8]	; (106c <register_fini+0x10>)
    1062:	f000 b805 	b.w	1070 <atexit>
    1066:	4770      	bx	lr
    1068:	00000000 	.word	0x00000000
    106c:	0000107d 	.word	0x0000107d

00001070 <atexit>:
    1070:	2300      	movs	r3, #0
    1072:	4601      	mov	r1, r0
    1074:	461a      	mov	r2, r3
    1076:	4618      	mov	r0, r3
    1078:	f000 b81e 	b.w	10b8 <__register_exitproc>

0000107c <__libc_fini_array>:
    107c:	b538      	push	{r3, r4, r5, lr}
    107e:	4c0a      	ldr	r4, [pc, #40]	; (10a8 <__libc_fini_array+0x2c>)
    1080:	4d0a      	ldr	r5, [pc, #40]	; (10ac <__libc_fini_array+0x30>)
    1082:	1b64      	subs	r4, r4, r5
    1084:	10a4      	asrs	r4, r4, #2
    1086:	d00a      	beq.n	109e <__libc_fini_array+0x22>
    1088:	f104 4380 	add.w	r3, r4, #1073741824	; 0x40000000
    108c:	3b01      	subs	r3, #1
    108e:	eb05 0583 	add.w	r5, r5, r3, lsl #2
    1092:	3c01      	subs	r4, #1
    1094:	f855 3904 	ldr.w	r3, [r5], #-4
    1098:	4798      	blx	r3
    109a:	2c00      	cmp	r4, #0
    109c:	d1f9      	bne.n	1092 <__libc_fini_array+0x16>
    109e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    10a2:	f000 b881 	b.w	11a8 <_fini>
    10a6:	bf00      	nop
    10a8:	000011b8 	.word	0x000011b8
    10ac:	000011b4 	.word	0x000011b4

000010b0 <__retarget_lock_acquire_recursive>:
    10b0:	4770      	bx	lr
    10b2:	bf00      	nop

000010b4 <__retarget_lock_release_recursive>:
    10b4:	4770      	bx	lr
    10b6:	bf00      	nop

000010b8 <__register_exitproc>:
    10b8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    10bc:	4d2c      	ldr	r5, [pc, #176]	; (1170 <__register_exitproc+0xb8>)
    10be:	4606      	mov	r6, r0
    10c0:	6828      	ldr	r0, [r5, #0]
    10c2:	4698      	mov	r8, r3
    10c4:	460f      	mov	r7, r1
    10c6:	4691      	mov	r9, r2
    10c8:	f7ff fff2 	bl	10b0 <__retarget_lock_acquire_recursive>
    10cc:	4b29      	ldr	r3, [pc, #164]	; (1174 <__register_exitproc+0xbc>)
    10ce:	681c      	ldr	r4, [r3, #0]
    10d0:	f8d4 3148 	ldr.w	r3, [r4, #328]	; 0x148
    10d4:	2b00      	cmp	r3, #0
    10d6:	d03e      	beq.n	1156 <__register_exitproc+0x9e>
    10d8:	685a      	ldr	r2, [r3, #4]
    10da:	2a1f      	cmp	r2, #31
    10dc:	dc1c      	bgt.n	1118 <__register_exitproc+0x60>
    10de:	f102 0e01 	add.w	lr, r2, #1
    10e2:	b176      	cbz	r6, 1102 <__register_exitproc+0x4a>
    10e4:	eb03 0182 	add.w	r1, r3, r2, lsl #2
    10e8:	2401      	movs	r4, #1
    10ea:	f8c1 9088 	str.w	r9, [r1, #136]	; 0x88
    10ee:	f8d3 0188 	ldr.w	r0, [r3, #392]	; 0x188
    10f2:	4094      	lsls	r4, r2
    10f4:	4320      	orrs	r0, r4
    10f6:	2e02      	cmp	r6, #2
    10f8:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
    10fc:	f8c1 8108 	str.w	r8, [r1, #264]	; 0x108
    1100:	d023      	beq.n	114a <__register_exitproc+0x92>
    1102:	3202      	adds	r2, #2
    1104:	f8c3 e004 	str.w	lr, [r3, #4]
    1108:	6828      	ldr	r0, [r5, #0]
    110a:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
    110e:	f7ff ffd1 	bl	10b4 <__retarget_lock_release_recursive>
    1112:	2000      	movs	r0, #0
    1114:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    1118:	4b17      	ldr	r3, [pc, #92]	; (1178 <__register_exitproc+0xc0>)
    111a:	b30b      	cbz	r3, 1160 <__register_exitproc+0xa8>
    111c:	f44f 70c8 	mov.w	r0, #400	; 0x190
    1120:	f3af 8000 	nop.w
    1124:	4603      	mov	r3, r0
    1126:	b1d8      	cbz	r0, 1160 <__register_exitproc+0xa8>
    1128:	f8d4 2148 	ldr.w	r2, [r4, #328]	; 0x148
    112c:	6002      	str	r2, [r0, #0]
    112e:	2100      	movs	r1, #0
    1130:	6041      	str	r1, [r0, #4]
    1132:	460a      	mov	r2, r1
    1134:	f8c4 0148 	str.w	r0, [r4, #328]	; 0x148
    1138:	f04f 0e01 	mov.w	lr, #1
    113c:	f8c0 1188 	str.w	r1, [r0, #392]	; 0x188
    1140:	f8c0 118c 	str.w	r1, [r0, #396]	; 0x18c
    1144:	2e00      	cmp	r6, #0
    1146:	d0dc      	beq.n	1102 <__register_exitproc+0x4a>
    1148:	e7cc      	b.n	10e4 <__register_exitproc+0x2c>
    114a:	f8d3 118c 	ldr.w	r1, [r3, #396]	; 0x18c
    114e:	430c      	orrs	r4, r1
    1150:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
    1154:	e7d5      	b.n	1102 <__register_exitproc+0x4a>
    1156:	f504 73a6 	add.w	r3, r4, #332	; 0x14c
    115a:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
    115e:	e7bb      	b.n	10d8 <__register_exitproc+0x20>
    1160:	6828      	ldr	r0, [r5, #0]
    1162:	f7ff ffa7 	bl	10b4 <__retarget_lock_release_recursive>
    1166:	f04f 30ff 	mov.w	r0, #4294967295
    116a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    116e:	bf00      	nop
    1170:	20000460 	.word	0x20000460
    1174:	00001190 	.word	0x00001190
    1178:	00000000 	.word	0x00000000
    117c:	4c4c4548 	.word	0x4c4c4548
    1180:	0000004f 	.word	0x0000004f
    1184:	61206f74 	.word	0x61206f74
    1188:	69756472 	.word	0x69756472
    118c:	00006f6e 	.word	0x00006f6e

00001190 <_global_impure_ptr>:
    1190:	20000038                                8.. 

00001194 <_init>:
    1194:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1196:	bf00      	nop
    1198:	bcf8      	pop	{r3, r4, r5, r6, r7}
    119a:	bc08      	pop	{r3}
    119c:	469e      	mov	lr, r3
    119e:	4770      	bx	lr

000011a0 <__init_array_start>:
    11a0:	0000105d 	.word	0x0000105d

000011a4 <__frame_dummy_init_array_entry>:
    11a4:	000001a5                                ....

000011a8 <_fini>:
    11a8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11aa:	bf00      	nop
    11ac:	bcf8      	pop	{r3, r4, r5, r6, r7}
    11ae:	bc08      	pop	{r3}
    11b0:	469e      	mov	lr, r3
    11b2:	4770      	bx	lr

000011b4 <__fini_array_start>:
    11b4:	00000181 	.word	0x00000181

Disassembly of section .relocate:

20000000 <bpm_ps_no_halt_exec>:
	BPM_UNLOCK(PMCON);
20000000:	4a07      	ldr	r2, [pc, #28]	; (20000020 <bpm_ps_no_halt_exec+0x20>)
20000002:	4b08      	ldr	r3, [pc, #32]	; (20000024 <bpm_ps_no_halt_exec+0x24>)
20000004:	619a      	str	r2, [r3, #24]
	bpm->BPM_PMCON = pmcon;
20000006:	61c1      	str	r1, [r0, #28]
		b_psok = (BPM->BPM_SR & BPM_SR_PSOK);
20000008:	4619      	mov	r1, r3
		b_timeout = (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk);
2000000a:	4a07      	ldr	r2, [pc, #28]	; (20000028 <bpm_ps_no_halt_exec+0x28>)
		b_psok = (BPM->BPM_SR & BPM_SR_PSOK);
2000000c:	6948      	ldr	r0, [r1, #20]
		b_timeout = (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk);
2000000e:	6813      	ldr	r3, [r2, #0]
20000010:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
	} while (!b_psok && !b_timeout);
20000014:	f010 0001 	ands.w	r0, r0, #1
20000018:	d101      	bne.n	2000001e <bpm_ps_no_halt_exec+0x1e>
2000001a:	2b00      	cmp	r3, #0
2000001c:	d0f6      	beq.n	2000000c <bpm_ps_no_halt_exec+0xc>
}
2000001e:	4770      	bx	lr
20000020:	aa00001c 	.word	0xaa00001c
20000024:	400f0000 	.word	0x400f0000
20000028:	e000e010 	.word	0xe000e010

2000002c <flashcalw_wait_until_ready>:
2000002c:	00000bb5                                ....

20000030 <g_interrupt_enabled>:
20000030:	00000001 00000000                       ........

20000038 <impure_data>:
20000038:	00000000 20000324 2000038c 200003f4     ....$.. ... ... 
	...
200000e0:	00000001 00000000 abcd330e e66d1234     .........3..4.m.
200000f0:	0005deec 0000000b 00000000 00000000     ................
	...

20000460 <__atexit_recursive_mutex>:
20000460:	200004bc                                ... 
